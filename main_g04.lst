CCS PCM C Compiler, Version 4.084, 44421               23-May-11 11:09

               Filename: main_g04.lst

               ROM used: 6778 words (83%)
                         Largest free fragment is 1329
               RAM used: 172 (47%) at main() level
                         326 (89%) worst case
               Stack:    8 worst case (2 in main + 6 for interrupts)

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   165
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  MOVLW  8C
001A:  MOVWF  04
001B:  BTFSS  00.6
001C:  GOTO   01F
001D:  BTFSC  0C.6
001E:  GOTO   03C
001F:  MOVLW  8C
0020:  MOVWF  04
0021:  BTFSS  00.5
0022:  GOTO   025
0023:  BTFSC  0C.5
0024:  GOTO   03F
0025:  BTFSS  0B.5
0026:  GOTO   029
0027:  BTFSC  0B.2
0028:  GOTO   042
0029:  MOVF   22,W
002A:  MOVWF  04
002B:  MOVF   23,W
002C:  MOVWF  77
002D:  MOVF   24,W
002E:  MOVWF  78
002F:  MOVF   25,W
0030:  MOVWF  79
0031:  MOVF   26,W
0032:  MOVWF  7A
0033:  MOVF   27,W
0034:  MOVWF  7B
0035:  MOVF   20,W
0036:  MOVWF  0A
0037:  SWAPF  21,W
0038:  MOVWF  03
0039:  SWAPF  7F,F
003A:  SWAPF  7F,W
003B:  RETFIE
003C:  BCF    0A.3
003D:  BSF    0A.4
003E:  GOTO   6FC
003F:  BCF    0A.3
0040:  BSF    0A.4
0041:  GOTO   116
0042:  BCF    0A.3
0043:  BCF    0A.4
0044:  GOTO   3EB
.................... /* Archivo unico.                       AUTOR: GUSTAVO D. GIL 
....................                                      FECHA: 22/05/2011 
....................  
.................... Control de velocidad y posicion por IRQ en FixedPoint. 
....................  
.................... // MENU QUE SE DESPLIEGA POR DEFAULT         
....................             printf("\n\Menu:");    
....................             printf("\n\r   '1' POS -> POTE");      
....................             printf("\n\r   '2' POS -> TECLADO"); 
....................             printf("\n\r   '3' VEL -> POTE"); 
....................             printf("\n\r   '4' VEL -> TECLADO\n\r"); 
....................             printf("\n\r   '5' Edicion Controlador POS"); 
....................             printf("\n\r   '6' Edicion Controlador VEL"); 
....................             printf("\n\r   '7' Controlador por defecto Ahhh ... g04"); 
.................... // 
.................... // Recibe:  nada 
.................... // Retorna: nada 
.................... // ===== 
.................... */ 
....................  
.................... // Librerias 
.................... #include "main.h" 
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device *=16 
.................... //#device ICD=TRUE		// comentar para programar 
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(clock=8000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1978:  BCF    03.5
1979:  CLRF   29
197A:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0C20:  BSF    03.6
0C21:  CLRF   30
....................    sign = 0; 
0C22:  CLRF   2E
....................    base = 10; 
0C23:  MOVLW  0A
0C24:  MOVWF  2F
....................    result = 0; 
0C25:  CLRF   2D
0C26:  CLRF   2C
0C27:  CLRF   2B
0C28:  CLRF   2A
....................  
....................    if (!s) 
0C29:  MOVF   28,W
0C2A:  IORWF  29,W
0C2B:  BTFSS  03.2
0C2C:  GOTO   432
....................       return 0; 
0C2D:  CLRF   77
0C2E:  CLRF   78
0C2F:  CLRF   79
0C30:  CLRF   7A
0C31:  GOTO   59D
....................    c = s[index++]; 
0C32:  MOVF   30,W
0C33:  INCF   30,F
0C34:  ADDWF  28,W
0C35:  MOVWF  04
0C36:  BCF    03.7
0C37:  BTFSC  29.0
0C38:  BSF    03.7
0C39:  MOVF   00,W
0C3A:  MOVWF  31
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0C3B:  MOVF   31,W
0C3C:  SUBLW  2D
0C3D:  BTFSS  03.2
0C3E:  GOTO   44B
....................    { 
....................       sign = 1;         // Set the sign to negative 
0C3F:  MOVLW  01
0C40:  MOVWF  2E
....................       c = s[index++]; 
0C41:  MOVF   30,W
0C42:  INCF   30,F
0C43:  ADDWF  28,W
0C44:  MOVWF  04
0C45:  BCF    03.7
0C46:  BTFSC  29.0
0C47:  BSF    03.7
0C48:  MOVF   00,W
0C49:  MOVWF  31
....................    } 
....................    else if (c == '+') 
0C4A:  GOTO   458
0C4B:  MOVF   31,W
0C4C:  SUBLW  2B
0C4D:  BTFSS  03.2
0C4E:  GOTO   458
....................    { 
....................       c = s[index++]; 
0C4F:  MOVF   30,W
0C50:  INCF   30,F
0C51:  ADDWF  28,W
0C52:  MOVWF  04
0C53:  BCF    03.7
0C54:  BTFSC  29.0
0C55:  BSF    03.7
0C56:  MOVF   00,W
0C57:  MOVWF  31
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0C58:  MOVF   31,W
0C59:  SUBLW  2F
0C5A:  BTFSC  03.0
0C5B:  GOTO   584
0C5C:  MOVF   31,W
0C5D:  SUBLW  39
0C5E:  BTFSS  03.0
0C5F:  GOTO   584
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0C60:  MOVF   31,W
0C61:  SUBLW  30
0C62:  BTFSS  03.2
0C63:  GOTO   484
0C64:  MOVF   30,W
0C65:  ADDWF  28,W
0C66:  MOVWF  04
0C67:  BCF    03.7
0C68:  BTFSC  29.0
0C69:  BSF    03.7
0C6A:  MOVF   00,W
0C6B:  SUBLW  78
0C6C:  BTFSC  03.2
0C6D:  GOTO   478
0C6E:  MOVF   30,W
0C6F:  ADDWF  28,W
0C70:  MOVWF  04
0C71:  BCF    03.7
0C72:  BTFSC  29.0
0C73:  BSF    03.7
0C74:  MOVF   00,W
0C75:  SUBLW  58
0C76:  BTFSS  03.2
0C77:  GOTO   484
....................       { 
....................          base = 16; 
0C78:  MOVLW  10
0C79:  MOVWF  2F
....................          index++; 
0C7A:  INCF   30,F
....................          c = s[index++]; 
0C7B:  MOVF   30,W
0C7C:  INCF   30,F
0C7D:  ADDWF  28,W
0C7E:  MOVWF  04
0C7F:  BCF    03.7
0C80:  BTFSC  29.0
0C81:  BSF    03.7
0C82:  MOVF   00,W
0C83:  MOVWF  31
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0C84:  MOVF   2F,W
0C85:  SUBLW  0A
0C86:  BTFSS  03.2
0C87:  GOTO   4DB
....................       { 
....................          while (c >= '0' && c <= '9') { 
0C88:  MOVF   31,W
0C89:  SUBLW  2F
0C8A:  BTFSC  03.0
0C8B:  GOTO   4DA
0C8C:  MOVF   31,W
0C8D:  SUBLW  39
0C8E:  BTFSS  03.0
0C8F:  GOTO   4DA
....................             result = (result << 1) + (result << 3);  // result *= 10; 
0C90:  BCF    03.0
0C91:  RLF    2A,W
0C92:  MOVWF  33
0C93:  RLF    2B,W
0C94:  MOVWF  34
0C95:  RLF    2C,W
0C96:  MOVWF  35
0C97:  RLF    2D,W
0C98:  MOVWF  36
0C99:  RLF    2A,W
0C9A:  MOVWF  77
0C9B:  RLF    2B,W
0C9C:  MOVWF  78
0C9D:  RLF    2C,W
0C9E:  MOVWF  79
0C9F:  RLF    2D,W
0CA0:  MOVWF  7A
0CA1:  RLF    77,F
0CA2:  RLF    78,F
0CA3:  RLF    79,F
0CA4:  RLF    7A,F
0CA5:  RLF    77,F
0CA6:  RLF    78,F
0CA7:  RLF    79,F
0CA8:  RLF    7A,F
0CA9:  MOVLW  F8
0CAA:  ANDWF  77,F
0CAB:  MOVF   33,W
0CAC:  ADDWF  77,F
0CAD:  MOVF   34,W
0CAE:  BTFSC  03.0
0CAF:  INCFSZ 34,W
0CB0:  ADDWF  78,F
0CB1:  MOVF   35,W
0CB2:  BTFSC  03.0
0CB3:  INCFSZ 35,W
0CB4:  ADDWF  79,F
0CB5:  MOVF   36,W
0CB6:  BTFSC  03.0
0CB7:  INCFSZ 36,W
0CB8:  ADDWF  7A,F
0CB9:  MOVF   7A,W
0CBA:  MOVWF  2D
0CBB:  MOVF   79,W
0CBC:  MOVWF  2C
0CBD:  MOVF   78,W
0CBE:  MOVWF  2B
0CBF:  MOVF   77,W
0CC0:  MOVWF  2A
....................             result += (c - '0'); 
0CC1:  MOVLW  30
0CC2:  SUBWF  31,W
0CC3:  ADDWF  2A,F
0CC4:  MOVLW  00
0CC5:  BTFSC  03.0
0CC6:  MOVLW  01
0CC7:  ADDWF  2B,F
0CC8:  MOVLW  00
0CC9:  BTFSC  03.0
0CCA:  MOVLW  01
0CCB:  ADDWF  2C,F
0CCC:  MOVLW  00
0CCD:  BTFSC  03.0
0CCE:  MOVLW  01
0CCF:  ADDWF  2D,F
....................             c = s[index++]; 
0CD0:  MOVF   30,W
0CD1:  INCF   30,F
0CD2:  ADDWF  28,W
0CD3:  MOVWF  04
0CD4:  BCF    03.7
0CD5:  BTFSC  29.0
0CD6:  BSF    03.7
0CD7:  MOVF   00,W
0CD8:  MOVWF  31
....................          } 
0CD9:  GOTO   488
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0CDA:  GOTO   584
0CDB:  MOVF   2F,W
0CDC:  SUBLW  10
0CDD:  BTFSS  03.2
0CDE:  GOTO   584
....................       { 
....................          c = toupper(c); 
0CDF:  MOVF   31,W
0CE0:  SUBLW  60
0CE1:  BTFSC  03.0
0CE2:  GOTO   4EA
0CE3:  MOVF   31,W
0CE4:  SUBLW  7A
0CE5:  BTFSS  03.0
0CE6:  GOTO   4EA
0CE7:  MOVF   31,W
0CE8:  ANDLW  DF
0CE9:  GOTO   4EB
0CEA:  MOVF   31,W
0CEB:  MOVWF  31
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0CEC:  MOVF   31,W
0CED:  SUBLW  2F
0CEE:  BTFSC  03.0
0CEF:  GOTO   4F4
0CF0:  MOVF   31,W
0CF1:  SUBLW  39
0CF2:  BTFSC  03.0
0CF3:  GOTO   4FC
0CF4:  MOVF   31,W
0CF5:  SUBLW  40
0CF6:  BTFSC  03.0
0CF7:  GOTO   584
0CF8:  MOVF   31,W
0CF9:  SUBLW  46
0CFA:  BTFSS  03.0
0CFB:  GOTO   584
....................             if (c >= '0' && c <= '9') 
0CFC:  MOVF   31,W
0CFD:  SUBLW  2F
0CFE:  BTFSC  03.0
0CFF:  GOTO   539
0D00:  MOVF   31,W
0D01:  SUBLW  39
0D02:  BTFSS  03.0
0D03:  GOTO   539
....................                result = (result << 4) + (c - '0'); 
0D04:  RLF    2A,W
0D05:  MOVWF  33
0D06:  RLF    2B,W
0D07:  MOVWF  34
0D08:  RLF    2C,W
0D09:  MOVWF  35
0D0A:  RLF    2D,W
0D0B:  MOVWF  36
0D0C:  RLF    33,F
0D0D:  RLF    34,F
0D0E:  RLF    35,F
0D0F:  RLF    36,F
0D10:  RLF    33,F
0D11:  RLF    34,F
0D12:  RLF    35,F
0D13:  RLF    36,F
0D14:  RLF    33,F
0D15:  RLF    34,F
0D16:  RLF    35,F
0D17:  RLF    36,F
0D18:  MOVLW  F0
0D19:  ANDWF  33,F
0D1A:  MOVLW  30
0D1B:  SUBWF  31,W
0D1C:  ADDWF  33,W
0D1D:  MOVWF  77
0D1E:  MOVF   34,W
0D1F:  MOVWF  78
0D20:  MOVLW  00
0D21:  BTFSC  03.0
0D22:  MOVLW  01
0D23:  ADDWF  78,F
0D24:  MOVF   35,W
0D25:  MOVWF  79
0D26:  MOVLW  00
0D27:  BTFSC  03.0
0D28:  MOVLW  01
0D29:  ADDWF  79,F
0D2A:  MOVF   36,W
0D2B:  MOVWF  7A
0D2C:  MOVLW  00
0D2D:  BTFSC  03.0
0D2E:  MOVLW  01
0D2F:  ADDWF  7A,F
0D30:  MOVF   7A,W
0D31:  MOVWF  2D
0D32:  MOVF   79,W
0D33:  MOVWF  2C
0D34:  MOVF   78,W
0D35:  MOVWF  2B
0D36:  MOVF   77,W
0D37:  MOVWF  2A
....................             else 
0D38:  GOTO   56E
....................                result = (result << 4) + (c - 'A' + 10); 
0D39:  RLF    2A,W
0D3A:  MOVWF  33
0D3B:  RLF    2B,W
0D3C:  MOVWF  34
0D3D:  RLF    2C,W
0D3E:  MOVWF  35
0D3F:  RLF    2D,W
0D40:  MOVWF  36
0D41:  RLF    33,F
0D42:  RLF    34,F
0D43:  RLF    35,F
0D44:  RLF    36,F
0D45:  RLF    33,F
0D46:  RLF    34,F
0D47:  RLF    35,F
0D48:  RLF    36,F
0D49:  RLF    33,F
0D4A:  RLF    34,F
0D4B:  RLF    35,F
0D4C:  RLF    36,F
0D4D:  MOVLW  F0
0D4E:  ANDWF  33,F
0D4F:  MOVLW  41
0D50:  SUBWF  31,W
0D51:  ADDLW  0A
0D52:  ADDWF  33,W
0D53:  MOVWF  77
0D54:  MOVF   34,W
0D55:  MOVWF  78
0D56:  MOVLW  00
0D57:  BTFSC  03.0
0D58:  MOVLW  01
0D59:  ADDWF  78,F
0D5A:  MOVF   35,W
0D5B:  MOVWF  79
0D5C:  MOVLW  00
0D5D:  BTFSC  03.0
0D5E:  MOVLW  01
0D5F:  ADDWF  79,F
0D60:  MOVF   36,W
0D61:  MOVWF  7A
0D62:  MOVLW  00
0D63:  BTFSC  03.0
0D64:  MOVLW  01
0D65:  ADDWF  7A,F
0D66:  MOVF   7A,W
0D67:  MOVWF  2D
0D68:  MOVF   79,W
0D69:  MOVWF  2C
0D6A:  MOVF   78,W
0D6B:  MOVWF  2B
0D6C:  MOVF   77,W
0D6D:  MOVWF  2A
....................  
....................             c = s[index++];c = toupper(c); 
0D6E:  MOVF   30,W
0D6F:  INCF   30,F
0D70:  ADDWF  28,W
0D71:  MOVWF  04
0D72:  BCF    03.7
0D73:  BTFSC  29.0
0D74:  BSF    03.7
0D75:  MOVF   00,W
0D76:  MOVWF  31
0D77:  SUBLW  60
0D78:  BTFSC  03.0
0D79:  GOTO   581
0D7A:  MOVF   31,W
0D7B:  SUBLW  7A
0D7C:  BTFSS  03.0
0D7D:  GOTO   581
0D7E:  MOVF   31,W
0D7F:  ANDLW  DF
0D80:  GOTO   582
0D81:  MOVF   31,W
0D82:  MOVWF  31
....................          } 
0D83:  GOTO   4EC
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0D84:  MOVF   2F,W
0D85:  SUBLW  0A
0D86:  BTFSS  03.2
0D87:  GOTO   595
0D88:  DECFSZ 2E,W
0D89:  GOTO   595
....................       result = -result; 
0D8A:  COMF   2A,F
0D8B:  COMF   2B,F
0D8C:  COMF   2C,F
0D8D:  COMF   2D,F
0D8E:  INCF   2A,F
0D8F:  BTFSC  03.2
0D90:  INCF   2B,F
0D91:  BTFSC  03.2
0D92:  INCF   2C,F
0D93:  BTFSC  03.2
0D94:  INCF   2D,F
....................  
....................    return(result); 
0D95:  MOVF   2A,W
0D96:  MOVWF  77
0D97:  MOVF   2B,W
0D98:  MOVWF  78
0D99:  MOVF   2C,W
0D9A:  MOVWF  79
0D9B:  MOVF   2D,W
0D9C:  MOVWF  7A
.................... } 
0D9D:  BCF    03.6
0D9E:  RETLW  00
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Redefinicion de tipo de dato (32 bits signado) 
.................... typedef signed long long int g; 
....................  
.................... //Macros 
.................... #define FP(x,q)         ((x)*(1<<(q)))          // FixedPoint (Res: 2^q) 
.................... #define DD(x,q) (((x)>=0) ? ((x)>>(q)) : ~((~(x))>>(q))) 
.................... //#define PROD_FP(a,b,q)  (((a)*(b))>>(q)) 
.................... #define PROD_FP(a,b,q2) ((((a)*(b))>=0) ? (((a)*(b))>>(q2)) : ~((~((a)*(b)))>>(q2))) 
.................... #define DIV_FP(a,b,q3)   (((a)<<(q3))/(b)) 
....................  
.................... // Constantes 
.................... #define NVEL    1         // Grado del polinomio y[n] Vel 
.................... #define MVEL    1         // Grado del polinomio u[m] Vel 
.................... #define NPOS    0         // Grado del polinomio y[n] Pos 
.................... #define MPOS    1         // Grado del polinomio u[m] Pos 
.................... #define Q        8         // Resolucion de FixedPoint = 2^Q 
.................... #define RES     100 
.................... #define ESPERA  20 
.................... #define ESPERA2 500000 
....................  
.................... // Codificacion de 7 segmentos 
.................... #define N0 0xC0 
.................... #define N1 0xF9 
.................... #define N2 0xA4 
.................... #define N3 0xB0 
.................... #define N4 0x99 
.................... #define N5 0x92 
.................... #define N6 0x82 
.................... #define N7 0xF8 
.................... #define N8 0x80 
.................... #define N9 0x90 
.................... #define DIG_OFF 0x00      // Apagado del digito LCD 
....................  
....................  
.................... // COEFICIENTES DE LOS CONTROLADORES: 
.................... // ================================== 
.................... // Coeficientes para el control de Velocidad 
.................... #define B0_vel   FP(0.36,Q)               //  0.17  0.36  0.45 
.................... #define B1_vel   FP(-0.33,Q)               // -0.07 -0.33 -0.32 
.................... // Coeficientes para el control de Posicion 
.................... #define B0_pos   FP(0.28,Q)               //  0.20  0.28  0.75  
....................  
....................  
.................... ///////////////////////////// Registros del PIC ////////////////////////// 
.................... // Address de los puertos 
.................... #byte PORTA=0x05     //6 pines 
.................... #byte PORTB=0x06     // y dir 0x106 
.................... #byte PORTC=0x07 
.................... #byte PORTD=0x08 
.................... #byte PORTE=0x09     //3 pines 
....................  
.................... // Registros de configuracion I/O (TRIS) 
.................... #byte TRISA=0x85 
.................... #byte TRISB=0x86     // y dir 0x186 
.................... #byte TRISC=0x87 
.................... #byte TRISD=0x88 
.................... #byte TRISE=0x89 
....................  
.................... //definicion ADCON 
.................... #byte ADCON0 = 0x01F 
.................... #byte ADCON1 = 0x09F 
....................  
.................... //variables 
.................... #bit pulsador = PORTB.0 
.................... #bit uni      = PORTE.0 
.................... #bit dec      = PORTE.1 
.................... #bit cen      = PORTE.2 
....................  
....................  
.................... // Variables globales 
.................... int noise=0; 
*
197B:  CLRF   2F
.................... int modo;          //tipo de control 
.................... int texto[10], text1[5], text2[10], text3[5]; 
....................  
.................... g enuevo, valor, number, b0, b1;    
....................  
.................... g bvel[MVEL+1], avel[NVEL+1], velrefrpm, velact, velrpm, refevel; 
.................... g errovel[MVEL+1], ukvel[NVEL+1]; 
....................  
.................... g bpos[MPOS+1], apos[NPOS+1], posrefgr, posact, posgr, refepos; 
.................... g erropos[MPOS+1], ukpos[NPOS+1]; 
....................  
.................... g numero=0;   //numero a mostrar 
197C:  BSF    03.5
197D:  CLRF   64
197E:  CLRF   65
197F:  CLRF   66
1980:  CLRF   67
....................  
.................... int param=0;   //parametros por defecto de los controladores 
1981:  CLRF   7C
.................... int u, d, c, display=0;       //seleccion del display y barrido 
1982:  CLRF   69
....................  
....................  
.................... // ProdEsc_FP: realiza el producto escalar entre dos vectores. 
.................... // =========== 
.................... // Hace uso de la macro:  #define PROD_FP(a,b,q)  (((a)*(b))>>(q))                      
.................... // Realmente usa: PROD_FP(a,b,q2) ((((a)*(b))>=0) ? (((a)*(b))>>(q2)) : ~((~((a)*(b)))>>(q2))) 
.................... // 
.................... // Recibe: dos vectores tipo g y la longitud de los mismos 
.................... // Retorna: un resultado escalar tipo g 
.................... g ProdEsc_FP(g vec1[], g vec2[], int l) 
.................... { 
....................    g acc=0; 
*
0800:  BSF    03.6
0801:  CLRF   47
0802:  CLRF   48
0803:  CLRF   49
0804:  CLRF   4A
....................    g acc2; 
....................    int i; 
....................    for(i=0;i<l;i++) 
0805:  CLRF   4F
0806:  MOVF   46,W
0807:  SUBWF  4F,W
0808:  BTFSC  03.0
0809:  GOTO   17C
....................    { 
....................       acc2=PROD_FP(vec1[i],vec2[i],Q); 
080A:  RLF    4F,W
080B:  MOVWF  77
080C:  RLF    77,F
080D:  MOVLW  FC
080E:  ANDWF  77,F
080F:  MOVF   77,W
0810:  ADDWF  42,W
0811:  MOVWF  04
0812:  BCF    03.7
0813:  BTFSC  43.0
0814:  BSF    03.7
0815:  MOVF   00,W
0816:  MOVWF  50
0817:  INCF   04,F
0818:  MOVF   00,W
0819:  MOVWF  51
081A:  INCF   04,F
081B:  MOVF   00,W
081C:  MOVWF  52
081D:  INCF   04,F
081E:  MOVF   00,W
081F:  MOVWF  53
0820:  RLF    4F,W
0821:  MOVWF  77
0822:  RLF    77,F
0823:  MOVLW  FC
0824:  ANDWF  77,F
0825:  MOVF   77,W
0826:  ADDWF  44,W
0827:  MOVWF  04
0828:  BCF    03.7
0829:  BTFSC  45.0
082A:  BSF    03.7
082B:  MOVF   00,W
082C:  MOVWF  77
082D:  INCF   04,F
082E:  MOVF   00,W
082F:  MOVWF  78
0830:  INCF   04,F
0831:  MOVF   00,W
0832:  MOVWF  79
0833:  INCF   04,F
0834:  MOVF   00,W
0835:  MOVWF  7A
0836:  MOVWF  57
0837:  MOVF   79,W
0838:  MOVWF  56
0839:  MOVF   78,W
083A:  MOVWF  55
083B:  MOVF   77,W
083C:  MOVWF  54
083D:  CLRF   59
083E:  MOVF   04,W
083F:  MOVWF  58
0840:  BCF    59.0
0841:  BTFSC  03.7
0842:  BSF    59.0
0843:  MOVF   53,W
0844:  BSF    03.5
0845:  MOVWF  38
0846:  BCF    03.5
0847:  MOVF   52,W
0848:  BSF    03.5
0849:  MOVWF  37
084A:  BCF    03.5
084B:  MOVF   51,W
084C:  BSF    03.5
084D:  MOVWF  36
084E:  BCF    03.5
084F:  MOVF   50,W
0850:  BSF    03.5
0851:  MOVWF  35
0852:  BCF    03.5
0853:  MOVF   57,W
0854:  BSF    03.5
0855:  MOVWF  3C
0856:  BCF    03.5
0857:  MOVF   56,W
0858:  BSF    03.5
0859:  MOVWF  3B
085A:  BCF    03.5
085B:  MOVF   55,W
085C:  BSF    03.5
085D:  MOVWF  3A
085E:  BCF    03.5
085F:  MOVF   54,W
0860:  BSF    03.5
0861:  MOVWF  39
0862:  BCF    0A.3
0863:  BCF    03.5
0864:  BCF    03.6
0865:  CALL   424
0866:  BSF    0A.3
0867:  BSF    03.6
0868:  MOVF   58,W
0869:  MOVWF  04
086A:  BCF    03.7
086B:  BTFSC  59.0
086C:  BSF    03.7
086D:  MOVF   7A,W
086E:  MOVWF  54
086F:  MOVF   79,W
0870:  MOVWF  53
0871:  MOVF   78,W
0872:  MOVWF  52
0873:  MOVF   77,W
0874:  MOVWF  51
0875:  BTFSC  54.7
0876:  GOTO   0EA
0877:  RLF    4F,W
0878:  MOVWF  77
0879:  RLF    77,F
087A:  MOVLW  FC
087B:  ANDWF  77,F
087C:  MOVF   77,W
087D:  ADDWF  42,W
087E:  MOVWF  04
087F:  BCF    03.7
0880:  BTFSC  43.0
0881:  BSF    03.7
0882:  MOVF   00,W
0883:  MOVWF  55
0884:  INCF   04,F
0885:  MOVF   00,W
0886:  MOVWF  56
0887:  INCF   04,F
0888:  MOVF   00,W
0889:  MOVWF  57
088A:  INCF   04,F
088B:  MOVF   00,W
088C:  MOVWF  58
088D:  RLF    4F,W
088E:  MOVWF  77
088F:  RLF    77,F
0890:  MOVLW  FC
0891:  ANDWF  77,F
0892:  MOVF   77,W
0893:  ADDWF  44,W
0894:  MOVWF  04
0895:  BCF    03.7
0896:  BTFSC  45.0
0897:  BSF    03.7
0898:  MOVF   00,W
0899:  MOVWF  77
089A:  INCF   04,F
089B:  MOVF   00,W
089C:  MOVWF  78
089D:  INCF   04,F
089E:  MOVF   00,W
089F:  MOVWF  79
08A0:  INCF   04,F
08A1:  MOVF   00,W
08A2:  MOVWF  7A
08A3:  MOVWF  5D
08A4:  MOVF   79,W
08A5:  MOVWF  5C
08A6:  MOVF   78,W
08A7:  MOVWF  5B
08A8:  MOVF   77,W
08A9:  MOVWF  5A
08AA:  CLRF   5F
08AB:  MOVF   04,W
08AC:  MOVWF  5E
08AD:  BCF    5F.0
08AE:  BTFSC  03.7
08AF:  BSF    5F.0
08B0:  MOVF   58,W
08B1:  BSF    03.5
08B2:  MOVWF  38
08B3:  BCF    03.5
08B4:  MOVF   57,W
08B5:  BSF    03.5
08B6:  MOVWF  37
08B7:  BCF    03.5
08B8:  MOVF   56,W
08B9:  BSF    03.5
08BA:  MOVWF  36
08BB:  BCF    03.5
08BC:  MOVF   55,W
08BD:  BSF    03.5
08BE:  MOVWF  35
08BF:  BCF    03.5
08C0:  MOVF   5D,W
08C1:  BSF    03.5
08C2:  MOVWF  3C
08C3:  BCF    03.5
08C4:  MOVF   5C,W
08C5:  BSF    03.5
08C6:  MOVWF  3B
08C7:  BCF    03.5
08C8:  MOVF   5B,W
08C9:  BSF    03.5
08CA:  MOVWF  3A
08CB:  BCF    03.5
08CC:  MOVF   5A,W
08CD:  BSF    03.5
08CE:  MOVWF  39
08CF:  BCF    0A.3
08D0:  BCF    03.5
08D1:  BCF    03.6
08D2:  CALL   424
08D3:  BSF    0A.3
08D4:  BSF    03.6
08D5:  MOVF   5E,W
08D6:  MOVWF  04
08D7:  BCF    03.7
08D8:  BTFSC  5F.0
08D9:  BSF    03.7
08DA:  MOVF   7A,W
08DB:  MOVWF  59
08DC:  MOVF   79,W
08DD:  MOVWF  58
08DE:  MOVF   78,W
08DF:  MOVWF  57
08E0:  MOVF   77,W
08E1:  MOVWF  56
08E2:  MOVF   57,W
08E3:  MOVWF  77
08E4:  MOVF   58,W
08E5:  MOVWF  78
08E6:  MOVF   59,W
08E7:  MOVWF  79
08E8:  CLRF   7A
08E9:  GOTO   164
08EA:  RLF    4F,W
08EB:  MOVWF  77
08EC:  RLF    77,F
08ED:  MOVLW  FC
08EE:  ANDWF  77,F
08EF:  MOVF   77,W
08F0:  ADDWF  42,W
08F1:  MOVWF  04
08F2:  BCF    03.7
08F3:  BTFSC  43.0
08F4:  BSF    03.7
08F5:  MOVF   00,W
08F6:  MOVWF  5C
08F7:  INCF   04,F
08F8:  MOVF   00,W
08F9:  MOVWF  5D
08FA:  INCF   04,F
08FB:  MOVF   00,W
08FC:  MOVWF  5E
08FD:  INCF   04,F
08FE:  MOVF   00,W
08FF:  MOVWF  5F
0900:  RLF    4F,W
0901:  MOVWF  77
0902:  RLF    77,F
0903:  MOVLW  FC
0904:  ANDWF  77,F
0905:  MOVF   77,W
0906:  ADDWF  44,W
0907:  MOVWF  04
0908:  BCF    03.7
0909:  BTFSC  45.0
090A:  BSF    03.7
090B:  MOVF   00,W
090C:  MOVWF  77
090D:  INCF   04,F
090E:  MOVF   00,W
090F:  MOVWF  78
0910:  INCF   04,F
0911:  MOVF   00,W
0912:  MOVWF  79
0913:  INCF   04,F
0914:  MOVF   00,W
0915:  MOVWF  7A
0916:  MOVWF  63
0917:  MOVF   79,W
0918:  MOVWF  62
0919:  MOVF   78,W
091A:  MOVWF  61
091B:  MOVF   77,W
091C:  MOVWF  60
091D:  CLRF   65
091E:  MOVF   04,W
091F:  MOVWF  64
0920:  BCF    65.0
0921:  BTFSC  03.7
0922:  BSF    65.0
0923:  MOVF   5F,W
0924:  BSF    03.5
0925:  MOVWF  38
0926:  BCF    03.5
0927:  MOVF   5E,W
0928:  BSF    03.5
0929:  MOVWF  37
092A:  BCF    03.5
092B:  MOVF   5D,W
092C:  BSF    03.5
092D:  MOVWF  36
092E:  BCF    03.5
092F:  MOVF   5C,W
0930:  BSF    03.5
0931:  MOVWF  35
0932:  BCF    03.5
0933:  MOVF   63,W
0934:  BSF    03.5
0935:  MOVWF  3C
0936:  BCF    03.5
0937:  MOVF   62,W
0938:  BSF    03.5
0939:  MOVWF  3B
093A:  BCF    03.5
093B:  MOVF   61,W
093C:  BSF    03.5
093D:  MOVWF  3A
093E:  BCF    03.5
093F:  MOVF   60,W
0940:  BSF    03.5
0941:  MOVWF  39
0942:  BCF    0A.3
0943:  BCF    03.5
0944:  BCF    03.6
0945:  CALL   424
0946:  BSF    0A.3
0947:  BSF    03.6
0948:  MOVF   64,W
0949:  MOVWF  04
094A:  BCF    03.7
094B:  BTFSC  65.0
094C:  BSF    03.7
094D:  MOVF   77,W
094E:  MOVWF  5D
094F:  COMF   5D,F
0950:  MOVF   78,W
0951:  MOVWF  5E
0952:  COMF   5E,F
0953:  MOVF   79,W
0954:  MOVWF  5F
0955:  COMF   5F,F
0956:  MOVF   7A,W
0957:  MOVWF  60
0958:  COMF   60,F
0959:  MOVF   5E,W
095A:  MOVWF  77
095B:  MOVF   5F,W
095C:  MOVWF  78
095D:  MOVF   60,W
095E:  MOVWF  79
095F:  CLRF   7A
0960:  COMF   77,F
0961:  COMF   78,F
0962:  COMF   79,F
0963:  COMF   7A,F
0964:  MOVF   7A,W
0965:  MOVWF  4E
0966:  MOVF   79,W
0967:  MOVWF  4D
0968:  MOVF   78,W
0969:  MOVWF  4C
096A:  MOVF   77,W
096B:  MOVWF  4B
....................       acc=acc+acc2; 
096C:  MOVF   4B,W
096D:  ADDWF  47,F
096E:  MOVF   4C,W
096F:  BTFSC  03.0
0970:  INCFSZ 4C,W
0971:  ADDWF  48,F
0972:  MOVF   4D,W
0973:  BTFSC  03.0
0974:  INCFSZ 4D,W
0975:  ADDWF  49,F
0976:  MOVF   4E,W
0977:  BTFSC  03.0
0978:  INCFSZ 4E,W
0979:  ADDWF  4A,F
....................    } 
097A:  INCF   4F,F
097B:  GOTO   006
....................    return acc; 
097C:  MOVF   47,W
097D:  MOVWF  77
097E:  MOVF   48,W
097F:  MOVWF  78
0980:  MOVF   49,W
0981:  MOVWF  79
0982:  MOVF   4A,W
0983:  MOVWF  7A
.................... } 
0984:  BCF    03.6
0985:  RETLW  00
....................  
....................  
.................... // lcd2: Convierte un numero decimal de 0 a 9 en codigo 7 segmentos  
.................... // ===== 
.................... // El display es del tipo 7 segmentos 
.................... // Posee DP:punto decimal, APAGADO del digito y ERROR 
.................... // 
.................... // Recibe: un numero en int 
.................... // Retorna: un codigo 7 seg en int 
.................... /*----------------------------------------------------------------- 
.................... Nota: el apagado del los digitos y el punto decimal no estan implementados ! 
.................... ------------------------------------------------------------------*/ 
.................... int lcd2(int n) 
.................... { 
....................    int code[10]; 
....................    *(code+0)=N0; 
*
1773:  MOVLW  01
1774:  MOVWF  7A
1775:  MOVLW  1A
1776:  MOVWF  04
1777:  BCF    03.7
1778:  BTFSC  7A.0
1779:  BSF    03.7
177A:  MOVLW  C0
177B:  MOVWF  00
....................    *(code+1)=N1; 
177C:  MOVLW  01
177D:  MOVWF  7A
177E:  MOVLW  1B
177F:  MOVWF  04
1780:  BCF    03.7
1781:  BTFSC  7A.0
1782:  BSF    03.7
1783:  MOVLW  F9
1784:  MOVWF  00
....................    *(code+2)=N2; 
1785:  MOVLW  01
1786:  MOVWF  7A
1787:  MOVLW  1C
1788:  MOVWF  04
1789:  BCF    03.7
178A:  BTFSC  7A.0
178B:  BSF    03.7
178C:  MOVLW  A4
178D:  MOVWF  00
....................    *(code+3)=N3; 
178E:  MOVLW  01
178F:  MOVWF  7A
1790:  MOVLW  1D
1791:  MOVWF  04
1792:  BCF    03.7
1793:  BTFSC  7A.0
1794:  BSF    03.7
1795:  MOVLW  B0
1796:  MOVWF  00
....................    *(code+4)=N4; 
1797:  MOVLW  01
1798:  MOVWF  7A
1799:  MOVLW  1E
179A:  MOVWF  04
179B:  BCF    03.7
179C:  BTFSC  7A.0
179D:  BSF    03.7
179E:  MOVLW  99
179F:  MOVWF  00
....................    *(code+5)=N5; 
17A0:  MOVLW  01
17A1:  MOVWF  7A
17A2:  MOVLW  1F
17A3:  MOVWF  04
17A4:  BCF    03.7
17A5:  BTFSC  7A.0
17A6:  BSF    03.7
17A7:  MOVLW  92
17A8:  MOVWF  00
....................    *(code+6)=N6; 
17A9:  MOVLW  01
17AA:  MOVWF  7A
17AB:  MOVLW  20
17AC:  MOVWF  04
17AD:  BCF    03.7
17AE:  BTFSC  7A.0
17AF:  BSF    03.7
17B0:  MOVLW  82
17B1:  MOVWF  00
....................    *(code+7)=N7; 
17B2:  MOVLW  01
17B3:  MOVWF  7A
17B4:  MOVLW  21
17B5:  MOVWF  04
17B6:  BCF    03.7
17B7:  BTFSC  7A.0
17B8:  BSF    03.7
17B9:  MOVLW  F8
17BA:  MOVWF  00
....................    *(code+8)=N8; 
17BB:  MOVLW  01
17BC:  MOVWF  7A
17BD:  MOVLW  22
17BE:  MOVWF  04
17BF:  BCF    03.7
17C0:  BTFSC  7A.0
17C1:  BSF    03.7
17C2:  MOVLW  80
17C3:  MOVWF  00
....................    *(code+9)=N9; 
17C4:  MOVLW  01
17C5:  MOVWF  7A
17C6:  MOVLW  23
17C7:  MOVWF  04
17C8:  BCF    03.7
17C9:  BTFSC  7A.0
17CA:  BSF    03.7
17CB:  MOVLW  90
17CC:  MOVWF  00
....................  
....................    return code[n]; 
17CD:  MOVLW  1A
17CE:  BSF    03.6
17CF:  ADDWF  19,W
17D0:  MOVWF  04
17D1:  BSF    03.7
17D2:  MOVF   00,W
17D3:  MOVWF  78
.................... } 
17D4:  BCF    03.6
17D5:  RETLW  00
....................  
.................... // display_FP: Funcion para descomponer numero de 3 digitos en los displays 
.................... // =========== 
.................... // 
.................... // Recibe: un numero en g 
.................... // Retorna: no retorna dada, afecta a var. globales u, d, c 
.................... void display_FP(g number) 
.................... {   
....................    g naux; 
....................    int aux;    
....................    if (number<0)  
*
1800:  BSF    03.5
1801:  BTFSS  6E.7
1802:  GOTO   023
....................       naux=-number; 
1803:  COMF   6B,W
1804:  BCF    03.5
1805:  BSF    03.6
1806:  MOVWF  10
1807:  BSF    03.5
1808:  BCF    03.6
1809:  COMF   6C,W
180A:  BCF    03.5
180B:  BSF    03.6
180C:  MOVWF  11
180D:  BSF    03.5
180E:  BCF    03.6
180F:  COMF   6D,W
1810:  BCF    03.5
1811:  BSF    03.6
1812:  MOVWF  12
1813:  BSF    03.5
1814:  BCF    03.6
1815:  COMF   6E,W
1816:  BCF    03.5
1817:  BSF    03.6
1818:  MOVWF  13
1819:  INCF   10,F
181A:  BTFSC  03.2
181B:  INCF   11,F
181C:  BTFSC  03.2
181D:  INCF   12,F
181E:  BTFSC  03.2
181F:  INCF   13,F
....................    else 
1820:  GOTO   039
1821:  BSF    03.5
1822:  BCF    03.6
....................       naux=number; 
1823:  MOVF   6E,W
1824:  BCF    03.5
1825:  BSF    03.6
1826:  MOVWF  13
1827:  BSF    03.5
1828:  BCF    03.6
1829:  MOVF   6D,W
182A:  BCF    03.5
182B:  BSF    03.6
182C:  MOVWF  12
182D:  BSF    03.5
182E:  BCF    03.6
182F:  MOVF   6C,W
1830:  BCF    03.5
1831:  BSF    03.6
1832:  MOVWF  11
1833:  BSF    03.5
1834:  BCF    03.6
1835:  MOVF   6B,W
1836:  BCF    03.5
1837:  BSF    03.6
1838:  MOVWF  10
1839:  BCF    03.6
183A:  CLRF   28
183B:  BTFSC  0B.7
183C:  BSF    28.7
183D:  BCF    0B.7
....................    u = lcd2(naux%10);   //unidades       
183E:  BSF    03.6
183F:  MOVF   13,W
1840:  BSF    03.5
1841:  MOVWF  3B
1842:  BCF    03.5
1843:  MOVF   12,W
1844:  BSF    03.5
1845:  MOVWF  3A
1846:  BCF    03.5
1847:  MOVF   11,W
1848:  BSF    03.5
1849:  MOVWF  39
184A:  BCF    03.5
184B:  MOVF   10,W
184C:  BSF    03.5
184D:  MOVWF  38
184E:  CLRF   3F
184F:  CLRF   3E
1850:  CLRF   3D
1851:  MOVLW  0A
1852:  MOVWF  3C
1853:  BCF    0A.4
1854:  BCF    0A.3
1855:  BCF    03.5
1856:  BCF    03.6
1857:  CALL   452
1858:  BSF    0A.4
1859:  BSF    0A.3
185A:  BTFSC  28.7
185B:  BSF    0B.7
185C:  MOVF   00,W
185D:  BSF    03.6
185E:  MOVWF  14
185F:  INCF   04,F
1860:  MOVF   00,W
1861:  MOVWF  15
1862:  INCF   04,F
1863:  MOVF   00,W
1864:  MOVWF  16
1865:  INCF   04,F
1866:  MOVF   00,W
1867:  MOVWF  17
1868:  MOVF   14,W
1869:  MOVWF  19
186A:  BCF    0A.3
186B:  BCF    03.6
186C:  CALL   773
186D:  BSF    0A.3
186E:  MOVF   78,W
186F:  MOVWF  7D
1870:  CLRF   28
1871:  BTFSC  0B.7
1872:  BSF    28.7
1873:  BCF    0B.7
....................    naux = naux/10; 
1874:  BSF    03.6
1875:  MOVF   13,W
1876:  BSF    03.5
1877:  MOVWF  3B
1878:  BCF    03.5
1879:  MOVF   12,W
187A:  BSF    03.5
187B:  MOVWF  3A
187C:  BCF    03.5
187D:  MOVF   11,W
187E:  BSF    03.5
187F:  MOVWF  39
1880:  BCF    03.5
1881:  MOVF   10,W
1882:  BSF    03.5
1883:  MOVWF  38
1884:  CLRF   3F
1885:  CLRF   3E
1886:  CLRF   3D
1887:  MOVLW  0A
1888:  MOVWF  3C
1889:  BCF    0A.4
188A:  BCF    0A.3
188B:  BCF    03.5
188C:  BCF    03.6
188D:  CALL   452
188E:  BSF    0A.4
188F:  BSF    0A.3
1890:  BTFSC  28.7
1891:  BSF    0B.7
1892:  MOVF   7A,W
1893:  BSF    03.6
1894:  MOVWF  13
1895:  MOVF   79,W
1896:  MOVWF  12
1897:  MOVF   78,W
1898:  MOVWF  11
1899:  MOVF   77,W
189A:  MOVWF  10
189B:  BCF    03.6
189C:  CLRF   28
189D:  BTFSC  0B.7
189E:  BSF    28.7
189F:  BCF    0B.7
....................    d = lcd2(naux%10);   //decenas 
18A0:  BSF    03.6
18A1:  MOVF   13,W
18A2:  BSF    03.5
18A3:  MOVWF  3B
18A4:  BCF    03.5
18A5:  MOVF   12,W
18A6:  BSF    03.5
18A7:  MOVWF  3A
18A8:  BCF    03.5
18A9:  MOVF   11,W
18AA:  BSF    03.5
18AB:  MOVWF  39
18AC:  BCF    03.5
18AD:  MOVF   10,W
18AE:  BSF    03.5
18AF:  MOVWF  38
18B0:  CLRF   3F
18B1:  CLRF   3E
18B2:  CLRF   3D
18B3:  MOVLW  0A
18B4:  MOVWF  3C
18B5:  BCF    0A.4
18B6:  BCF    0A.3
18B7:  BCF    03.5
18B8:  BCF    03.6
18B9:  CALL   452
18BA:  BSF    0A.4
18BB:  BSF    0A.3
18BC:  BTFSC  28.7
18BD:  BSF    0B.7
18BE:  MOVF   00,W
18BF:  BSF    03.6
18C0:  MOVWF  14
18C1:  INCF   04,F
18C2:  MOVF   00,W
18C3:  MOVWF  15
18C4:  INCF   04,F
18C5:  MOVF   00,W
18C6:  MOVWF  16
18C7:  INCF   04,F
18C8:  MOVF   00,W
18C9:  MOVWF  17
18CA:  MOVF   14,W
18CB:  MOVWF  19
18CC:  BCF    0A.3
18CD:  BCF    03.6
18CE:  CALL   773
18CF:  BSF    0A.3
18D0:  MOVF   78,W
18D1:  MOVWF  7E
18D2:  CLRF   28
18D3:  BTFSC  0B.7
18D4:  BSF    28.7
18D5:  BCF    0B.7
....................    naux = naux/10; 
18D6:  BSF    03.6
18D7:  MOVF   13,W
18D8:  BSF    03.5
18D9:  MOVWF  3B
18DA:  BCF    03.5
18DB:  MOVF   12,W
18DC:  BSF    03.5
18DD:  MOVWF  3A
18DE:  BCF    03.5
18DF:  MOVF   11,W
18E0:  BSF    03.5
18E1:  MOVWF  39
18E2:  BCF    03.5
18E3:  MOVF   10,W
18E4:  BSF    03.5
18E5:  MOVWF  38
18E6:  CLRF   3F
18E7:  CLRF   3E
18E8:  CLRF   3D
18E9:  MOVLW  0A
18EA:  MOVWF  3C
18EB:  BCF    0A.4
18EC:  BCF    0A.3
18ED:  BCF    03.5
18EE:  BCF    03.6
18EF:  CALL   452
18F0:  BSF    0A.4
18F1:  BSF    0A.3
18F2:  BTFSC  28.7
18F3:  BSF    0B.7
18F4:  MOVF   7A,W
18F5:  BSF    03.6
18F6:  MOVWF  13
18F7:  MOVF   79,W
18F8:  MOVWF  12
18F9:  MOVF   78,W
18FA:  MOVWF  11
18FB:  MOVF   77,W
18FC:  MOVWF  10
18FD:  BCF    03.6
18FE:  CLRF   28
18FF:  BTFSC  0B.7
1900:  BSF    28.7
1901:  BCF    0B.7
....................    aux = lcd2(naux%10); 
1902:  BSF    03.6
1903:  MOVF   13,W
1904:  BSF    03.5
1905:  MOVWF  3B
1906:  BCF    03.5
1907:  MOVF   12,W
1908:  BSF    03.5
1909:  MOVWF  3A
190A:  BCF    03.5
190B:  MOVF   11,W
190C:  BSF    03.5
190D:  MOVWF  39
190E:  BCF    03.5
190F:  MOVF   10,W
1910:  BSF    03.5
1911:  MOVWF  38
1912:  CLRF   3F
1913:  CLRF   3E
1914:  CLRF   3D
1915:  MOVLW  0A
1916:  MOVWF  3C
1917:  BCF    0A.4
1918:  BCF    0A.3
1919:  BCF    03.5
191A:  BCF    03.6
191B:  CALL   452
191C:  BSF    0A.4
191D:  BSF    0A.3
191E:  BTFSC  28.7
191F:  BSF    0B.7
1920:  MOVF   00,W
1921:  BSF    03.6
1922:  MOVWF  14
1923:  INCF   04,F
1924:  MOVF   00,W
1925:  MOVWF  15
1926:  INCF   04,F
1927:  MOVF   00,W
1928:  MOVWF  16
1929:  INCF   04,F
192A:  MOVF   00,W
192B:  MOVWF  17
192C:  MOVF   14,W
192D:  MOVWF  19
192E:  BCF    0A.3
192F:  BCF    03.6
1930:  CALL   773
1931:  BSF    0A.3
1932:  MOVF   78,W
1933:  BSF    03.5
1934:  MOVWF  6F
....................    if (number<0 && number>-200) 
1935:  BTFSS  6E.7
1936:  GOTO   15F
1937:  BTFSS  6E.7
1938:  GOTO   152
1939:  MOVF   6E,W
193A:  SUBLW  FE
193B:  BTFSC  03.0
193C:  GOTO   15F
193D:  XORLW  FF
193E:  BTFSS  03.2
193F:  GOTO   152
1940:  MOVF   6D,W
1941:  SUBLW  FE
1942:  BTFSC  03.0
1943:  GOTO   15F
1944:  XORLW  FF
1945:  BTFSS  03.2
1946:  GOTO   152
1947:  MOVF   6C,W
1948:  SUBLW  FE
1949:  BTFSC  03.0
194A:  GOTO   15F
194B:  XORLW  FF
194C:  BTFSS  03.2
194D:  GOTO   152
194E:  MOVF   6B,W
194F:  SUBLW  38
1950:  BTFSC  03.0
1951:  GOTO   15F
....................    {  if(aux==N0) 
1952:  MOVF   6F,W
1953:  SUBLW  C0
1954:  BTFSS  03.2
1955:  GOTO   158
....................          c = 0xBF;   //signo "-" 
1956:  MOVLW  BF
1957:  MOVWF  68
....................       if(aux==N1) 
1958:  MOVF   6F,W
1959:  SUBLW  F9
195A:  BTFSS  03.2
195B:  GOTO   15E
....................          c = 0xB9;   //numero "-1" 
195C:  MOVLW  B9
195D:  MOVWF  68
....................    } 
....................    else  
195E:  GOTO   161
....................       c=aux; 
195F:  MOVF   6F,W
1960:  MOVWF  68
.................... } 
1961:  BCF    03.5
1962:  BSF    0A.3
1963:  BSF    0A.4
1964:  GOTO   2CD (RETURN)
....................  
....................  
.................... // AdquiereValor: convierte un string en un numero tipo g 
.................... // ============== 
.................... // 
.................... // Recibe: un puntero a un vector de caracteres y un puntero a un string 
.................... // Retorna:  
.................... g AdquiereValor(char* cmd, char* palabra) 
.................... { 
....................    char *dp; 
....................    g valor=0; 
....................       dp=strstr(cmd,palabra);   // busca una cadena en otra 
....................       if (dp!=NULL) 
....................       {   dp=dp+strlen(palabra); 
....................          valor = atoi32(dp);       
....................       } 
....................    return valor; 
.................... } 
....................  
....................  
.................... // ini_cola: inicializa arrays tipo g 
.................... // ============ 
.................... // 
.................... // Recibe: puntero al vector de Stack, largo del Stack  <Globales>  
.................... // Retorna: nada 
.................... void ini_cola(g *tabla, int l) 
.................... { 
....................    int i; 
....................    for (i=0;i<l;i++) 
*
0FCF:  BSF    03.5
0FD0:  CLRF   6E
0FD1:  MOVF   6D,W
0FD2:  SUBWF  6E,W
0FD3:  BTFSC  03.0
0FD4:  GOTO   7E9
....................    { 
....................       tabla[i]=0; 
0FD5:  RLF    6E,W
0FD6:  MOVWF  77
0FD7:  RLF    77,F
0FD8:  MOVLW  FC
0FD9:  ANDWF  77,F
0FDA:  MOVF   77,W
0FDB:  ADDWF  6B,W
0FDC:  MOVWF  04
0FDD:  BCF    03.7
0FDE:  BTFSC  6C.0
0FDF:  BSF    03.7
0FE0:  CLRF   00
0FE1:  INCF   04,F
0FE2:  CLRF   00
0FE3:  INCF   04,F
0FE4:  CLRF   00
0FE5:  INCF   04,F
0FE6:  CLRF   00
....................    } 
0FE7:  INCF   6E,F
0FE8:  GOTO   7D1
.................... } 
0FE9:  BCF    03.5
0FEA:  RETLW  00
....................  
....................  
.................... // cola_FP: cola FIFO. 
.................... // ======== 
.................... // 
.................... // Recibe: puntero al vector de Stack previamente definido, largo del Stack, dato a ingresar 
.................... // Retorna: nada 
.................... void cola_FP(g *tabla, int l, g dataNew)       
.................... { 
....................    int i; 
....................    // SHIFT los datos de la cola FIFO (poco eficiente con muchos datos) 
....................    for (i=l-1;i>0;i--) 
*
0749:  MOVLW  01
074A:  BSF    03.6
074B:  SUBWF  2E,W
074C:  MOVWF  33
074D:  MOVF   33,F
074E:  BTFSC  03.2
074F:  GOTO   78A
....................    { 
....................       tabla[i]=tabla[i-1]; 
0750:  RLF    33,W
0751:  MOVWF  77
0752:  RLF    77,F
0753:  MOVLW  FC
0754:  ANDWF  77,F
0755:  MOVF   77,W
0756:  ADDWF  2C,W
0757:  MOVWF  78
0758:  MOVF   2D,W
0759:  MOVWF  7A
075A:  BTFSC  03.0
075B:  INCF   7A,F
075C:  MOVF   78,W
075D:  MOVWF  34
075E:  MOVF   7A,W
075F:  MOVWF  35
0760:  MOVLW  01
0761:  SUBWF  33,W
0762:  MOVWF  77
0763:  RLF    77,F
0764:  RLF    77,F
0765:  MOVLW  FC
0766:  ANDWF  77,F
0767:  MOVF   77,W
0768:  ADDWF  2C,W
0769:  MOVWF  04
076A:  BCF    03.7
076B:  BTFSC  2D.0
076C:  BSF    03.7
076D:  MOVF   00,W
076E:  MOVWF  77
076F:  INCF   04,F
0770:  MOVF   00,W
0771:  MOVWF  78
0772:  INCF   04,F
0773:  MOVF   00,W
0774:  MOVWF  79
0775:  INCF   04,F
0776:  MOVF   00,W
0777:  MOVWF  7A
0778:  MOVF   34,W
0779:  MOVWF  04
077A:  BCF    03.7
077B:  BTFSC  35.0
077C:  BSF    03.7
077D:  MOVF   77,W
077E:  MOVWF  00
077F:  INCF   04,F
0780:  MOVF   78,W
0781:  MOVWF  00
0782:  INCF   04,F
0783:  MOVF   79,W
0784:  MOVWF  00
0785:  INCF   04,F
0786:  MOVF   7A,W
0787:  MOVWF  00
....................    } 
0788:  DECF   33,F
0789:  GOTO   74D
....................    // Insertamos el dataNew 
....................    tabla[0]=dataNew; 
078A:  MOVF   2C,W
078B:  MOVWF  04
078C:  BCF    03.7
078D:  BTFSC  2D.0
078E:  BSF    03.7
078F:  MOVF   2F,W
0790:  MOVWF  00
0791:  INCF   04,F
0792:  MOVF   30,W
0793:  MOVWF  00
0794:  INCF   04,F
0795:  MOVF   31,W
0796:  MOVWF  00
0797:  INCF   04,F
0798:  MOVF   32,W
0799:  MOVWF  00
.................... } 
079A:  BCF    03.6
079B:  RETLW  00
....................  
....................  
.................... // lineal_FP: Convierte un dato de entrada, en otro de salida a traves de una funcion lineal 
.................... // ========== 
.................... // Hace uso de las macros:   
.................... //   #define PROD_FP(a,b,q2) ((((a)*(b))>=0) ? (((a)*(b))>>(q2)) : ~((~((a)*(b)))>>(q2))) 
.................... //   #define DIV_FP(a,b,q3)   (((a)<<(q3))/(b)) 
.................... //   #define DD(x,q) (((x)>=0) ? ((x)>>(q)) : ~((~(x))>>(q))) 
.................... // 
.................... // Recibe: dato de entrada_X , Y_max, Y_min, X_max, X_min  <<g>> 
.................... // Retorna: dato convertido_Y (g) 
.................... g lineal_FP (g Xin, g Xmin, g Xmax, g Ymin, g Ymax)   
.................... {            
....................    g Yout; 
....................    // Ecuacion de la recta: 
....................    // Yout=Ymin+(Xin-Xmin)*((Ymax-Ymin)/(Xmax-Xmin)); 
....................    Yout=Ymin+(PROD_FP((Xin-Xmin),DIV_FP((Ymax-Ymin),(Xmax-Xmin),Q),Q)); 
*
04C3:  BSF    03.6
04C4:  MOVF   39,W
04C5:  SUBWF  35,W
04C6:  BSF    03.5
04C7:  MOVWF  10
04C8:  BCF    03.5
04C9:  MOVF   36,W
04CA:  BSF    03.5
04CB:  MOVWF  11
04CC:  BCF    03.5
04CD:  MOVF   3A,W
04CE:  BTFSS  03.0
04CF:  INCFSZ 3A,W
04D0:  GOTO   4D2
04D1:  GOTO   4D5
04D2:  BSF    03.5
04D3:  SUBWF  11,F
04D4:  BCF    03.5
04D5:  MOVF   37,W
04D6:  BSF    03.5
04D7:  MOVWF  12
04D8:  BCF    03.5
04D9:  MOVF   3B,W
04DA:  BTFSS  03.0
04DB:  INCFSZ 3B,W
04DC:  GOTO   4DE
04DD:  GOTO   4E1
04DE:  BSF    03.5
04DF:  SUBWF  12,F
04E0:  BCF    03.5
04E1:  MOVF   38,W
04E2:  BSF    03.5
04E3:  MOVWF  13
04E4:  BCF    03.5
04E5:  MOVF   3C,W
04E6:  BTFSS  03.0
04E7:  INCFSZ 3C,W
04E8:  GOTO   4EA
04E9:  GOTO   4ED
04EA:  BSF    03.5
04EB:  SUBWF  13,F
04EC:  BCF    03.5
04ED:  MOVF   41,W
04EE:  SUBWF  45,W
04EF:  BSF    03.5
04F0:  MOVWF  14
04F1:  BCF    03.5
04F2:  MOVF   46,W
04F3:  BSF    03.5
04F4:  MOVWF  15
04F5:  BCF    03.5
04F6:  MOVF   42,W
04F7:  BTFSS  03.0
04F8:  INCFSZ 42,W
04F9:  GOTO   4FB
04FA:  GOTO   4FE
04FB:  BSF    03.5
04FC:  SUBWF  15,F
04FD:  BCF    03.5
04FE:  MOVF   47,W
04FF:  BSF    03.5
0500:  MOVWF  16
0501:  BCF    03.5
0502:  MOVF   43,W
0503:  BTFSS  03.0
0504:  INCFSZ 43,W
0505:  GOTO   507
0506:  GOTO   50A
0507:  BSF    03.5
0508:  SUBWF  16,F
0509:  BCF    03.5
050A:  MOVF   48,W
050B:  BSF    03.5
050C:  MOVWF  17
050D:  BCF    03.5
050E:  MOVF   44,W
050F:  BTFSS  03.0
0510:  INCFSZ 44,W
0511:  GOTO   513
0512:  GOTO   516
0513:  BSF    03.5
0514:  SUBWF  17,F
0515:  BCF    03.5
0516:  BSF    03.5
0517:  MOVF   16,W
0518:  MOVWF  1C
0519:  MOVF   15,W
051A:  MOVWF  1B
051B:  MOVF   14,W
051C:  MOVWF  1A
051D:  CLRF   19
051E:  BCF    03.5
051F:  MOVF   39,W
0520:  SUBWF  3D,W
0521:  MOVWF  77
0522:  MOVF   3E,W
0523:  MOVWF  78
0524:  MOVF   3A,W
0525:  BTFSS  03.0
0526:  INCFSZ 3A,W
0527:  SUBWF  78,F
0528:  MOVF   3F,W
0529:  MOVWF  79
052A:  MOVF   3B,W
052B:  BTFSS  03.0
052C:  INCFSZ 3B,W
052D:  SUBWF  79,F
052E:  MOVF   40,W
052F:  MOVWF  7A
0530:  MOVF   3C,W
0531:  BTFSS  03.0
0532:  INCFSZ 3C,W
0533:  SUBWF  7A,F
0534:  MOVF   7A,W
0535:  BSF    03.5
0536:  MOVWF  20
0537:  MOVF   79,W
0538:  MOVWF  1F
0539:  MOVF   78,W
053A:  MOVWF  1E
053B:  MOVF   77,W
053C:  MOVWF  1D
053D:  MOVF   16,W
053E:  MOVWF  3B
053F:  MOVF   15,W
0540:  MOVWF  3A
0541:  MOVF   14,W
0542:  MOVWF  39
0543:  MOVF   19,W
0544:  MOVWF  38
0545:  MOVF   20,W
0546:  MOVWF  3F
0547:  MOVF   1F,W
0548:  MOVWF  3E
0549:  MOVF   1E,W
054A:  MOVWF  3D
054B:  MOVF   1D,W
054C:  MOVWF  3C
054D:  BCF    03.5
054E:  BCF    03.6
054F:  CALL   452
0550:  MOVF   7A,W
0551:  BSF    03.5
0552:  BSF    03.6
0553:  MOVWF  1D
0554:  MOVF   79,W
0555:  MOVWF  1C
0556:  MOVF   78,W
0557:  MOVWF  1B
0558:  MOVF   77,W
0559:  MOVWF  1A
055A:  MOVF   13,W
055B:  MOVWF  38
055C:  MOVF   12,W
055D:  MOVWF  37
055E:  MOVF   11,W
055F:  MOVWF  36
0560:  MOVF   10,W
0561:  MOVWF  35
0562:  MOVF   1D,W
0563:  MOVWF  3C
0564:  MOVF   1C,W
0565:  MOVWF  3B
0566:  MOVF   1B,W
0567:  MOVWF  3A
0568:  MOVF   1A,W
0569:  MOVWF  39
056A:  BCF    03.5
056B:  BCF    03.6
056C:  CALL   424
056D:  MOVF   7A,W
056E:  BSF    03.5
056F:  BSF    03.6
0570:  MOVWF  14
0571:  MOVF   79,W
0572:  MOVWF  13
0573:  MOVF   78,W
0574:  MOVWF  12
0575:  MOVF   77,W
0576:  MOVWF  11
0577:  BTFSC  14.7
0578:  GOTO   635
0579:  BCF    03.5
057A:  MOVF   39,W
057B:  SUBWF  35,W
057C:  BSF    03.5
057D:  MOVWF  1B
057E:  BCF    03.5
057F:  MOVF   36,W
0580:  BSF    03.5
0581:  MOVWF  1C
0582:  BCF    03.5
0583:  MOVF   3A,W
0584:  BTFSS  03.0
0585:  INCFSZ 3A,W
0586:  GOTO   588
0587:  GOTO   58B
0588:  BSF    03.5
0589:  SUBWF  1C,F
058A:  BCF    03.5
058B:  MOVF   37,W
058C:  BSF    03.5
058D:  MOVWF  1D
058E:  BCF    03.5
058F:  MOVF   3B,W
0590:  BTFSS  03.0
0591:  INCFSZ 3B,W
0592:  GOTO   594
0593:  GOTO   597
0594:  BSF    03.5
0595:  SUBWF  1D,F
0596:  BCF    03.5
0597:  MOVF   38,W
0598:  BSF    03.5
0599:  MOVWF  1E
059A:  BCF    03.5
059B:  MOVF   3C,W
059C:  BTFSS  03.0
059D:  INCFSZ 3C,W
059E:  GOTO   5A0
059F:  GOTO   5A3
05A0:  BSF    03.5
05A1:  SUBWF  1E,F
05A2:  BCF    03.5
05A3:  MOVF   41,W
05A4:  SUBWF  45,W
05A5:  BSF    03.5
05A6:  MOVWF  1F
05A7:  BCF    03.5
05A8:  MOVF   46,W
05A9:  BSF    03.5
05AA:  MOVWF  20
05AB:  BCF    03.5
05AC:  MOVF   42,W
05AD:  BTFSS  03.0
05AE:  INCFSZ 42,W
05AF:  GOTO   5B1
05B0:  GOTO   5B4
05B1:  BSF    03.5
05B2:  SUBWF  20,F
05B3:  BCF    03.5
05B4:  MOVF   47,W
05B5:  BSF    03.5
05B6:  MOVWF  21
05B7:  BCF    03.5
05B8:  MOVF   43,W
05B9:  BTFSS  03.0
05BA:  INCFSZ 43,W
05BB:  GOTO   5BD
05BC:  GOTO   5C0
05BD:  BSF    03.5
05BE:  SUBWF  21,F
05BF:  BCF    03.5
05C0:  MOVF   48,W
05C1:  BSF    03.5
05C2:  MOVWF  22
05C3:  BCF    03.5
05C4:  MOVF   44,W
05C5:  BTFSS  03.0
05C6:  INCFSZ 44,W
05C7:  GOTO   5C9
05C8:  GOTO   5CC
05C9:  BSF    03.5
05CA:  SUBWF  22,F
05CB:  BCF    03.5
05CC:  BSF    03.5
05CD:  MOVF   21,W
05CE:  MOVWF  27
05CF:  MOVF   20,W
05D0:  MOVWF  26
05D1:  MOVF   1F,W
05D2:  MOVWF  25
05D3:  CLRF   24
05D4:  BCF    03.5
05D5:  MOVF   39,W
05D6:  SUBWF  3D,W
05D7:  MOVWF  77
05D8:  MOVF   3E,W
05D9:  MOVWF  78
05DA:  MOVF   3A,W
05DB:  BTFSS  03.0
05DC:  INCFSZ 3A,W
05DD:  SUBWF  78,F
05DE:  MOVF   3F,W
05DF:  MOVWF  79
05E0:  MOVF   3B,W
05E1:  BTFSS  03.0
05E2:  INCFSZ 3B,W
05E3:  SUBWF  79,F
05E4:  MOVF   40,W
05E5:  MOVWF  7A
05E6:  MOVF   3C,W
05E7:  BTFSS  03.0
05E8:  INCFSZ 3C,W
05E9:  SUBWF  7A,F
05EA:  MOVF   7A,W
05EB:  BSF    03.5
05EC:  MOVWF  2B
05ED:  MOVF   79,W
05EE:  MOVWF  2A
05EF:  MOVF   78,W
05F0:  MOVWF  29
05F1:  MOVF   77,W
05F2:  MOVWF  28
05F3:  MOVF   21,W
05F4:  MOVWF  3B
05F5:  MOVF   20,W
05F6:  MOVWF  3A
05F7:  MOVF   1F,W
05F8:  MOVWF  39
05F9:  MOVF   24,W
05FA:  MOVWF  38
05FB:  MOVF   2B,W
05FC:  MOVWF  3F
05FD:  MOVF   2A,W
05FE:  MOVWF  3E
05FF:  MOVF   29,W
0600:  MOVWF  3D
0601:  MOVF   28,W
0602:  MOVWF  3C
0603:  BCF    03.5
0604:  BCF    03.6
0605:  CALL   452
0606:  MOVF   7A,W
0607:  BSF    03.5
0608:  BSF    03.6
0609:  MOVWF  28
060A:  MOVF   79,W
060B:  MOVWF  27
060C:  MOVF   78,W
060D:  MOVWF  26
060E:  MOVF   77,W
060F:  MOVWF  25
0610:  MOVF   1E,W
0611:  MOVWF  38
0612:  MOVF   1D,W
0613:  MOVWF  37
0614:  MOVF   1C,W
0615:  MOVWF  36
0616:  MOVF   1B,W
0617:  MOVWF  35
0618:  MOVF   28,W
0619:  MOVWF  3C
061A:  MOVF   27,W
061B:  MOVWF  3B
061C:  MOVF   26,W
061D:  MOVWF  3A
061E:  MOVF   25,W
061F:  MOVWF  39
0620:  BCF    03.5
0621:  BCF    03.6
0622:  CALL   424
0623:  MOVF   7A,W
0624:  BSF    03.5
0625:  BSF    03.6
0626:  MOVWF  1F
0627:  MOVF   79,W
0628:  MOVWF  1E
0629:  MOVF   78,W
062A:  MOVWF  1D
062B:  MOVF   77,W
062C:  MOVWF  1C
062D:  MOVF   1D,W
062E:  MOVWF  77
062F:  MOVF   1E,W
0630:  MOVWF  78
0631:  MOVF   1F,W
0632:  MOVWF  79
0633:  CLRF   7A
0634:  GOTO   6F8
0635:  BCF    03.5
0636:  MOVF   39,W
0637:  SUBWF  35,W
0638:  BSF    03.5
0639:  MOVWF  27
063A:  BCF    03.5
063B:  MOVF   36,W
063C:  BSF    03.5
063D:  MOVWF  28
063E:  BCF    03.5
063F:  MOVF   3A,W
0640:  BTFSS  03.0
0641:  INCFSZ 3A,W
0642:  GOTO   644
0643:  GOTO   647
0644:  BSF    03.5
0645:  SUBWF  28,F
0646:  BCF    03.5
0647:  MOVF   37,W
0648:  BSF    03.5
0649:  MOVWF  29
064A:  BCF    03.5
064B:  MOVF   3B,W
064C:  BTFSS  03.0
064D:  INCFSZ 3B,W
064E:  GOTO   650
064F:  GOTO   653
0650:  BSF    03.5
0651:  SUBWF  29,F
0652:  BCF    03.5
0653:  MOVF   38,W
0654:  BSF    03.5
0655:  MOVWF  2A
0656:  BCF    03.5
0657:  MOVF   3C,W
0658:  BTFSS  03.0
0659:  INCFSZ 3C,W
065A:  GOTO   65C
065B:  GOTO   65F
065C:  BSF    03.5
065D:  SUBWF  2A,F
065E:  BCF    03.5
065F:  MOVF   41,W
0660:  SUBWF  45,W
0661:  BSF    03.5
0662:  MOVWF  2B
0663:  BCF    03.5
0664:  MOVF   46,W
0665:  BSF    03.5
0666:  MOVWF  2C
0667:  BCF    03.5
0668:  MOVF   42,W
0669:  BTFSS  03.0
066A:  INCFSZ 42,W
066B:  GOTO   66D
066C:  GOTO   670
066D:  BSF    03.5
066E:  SUBWF  2C,F
066F:  BCF    03.5
0670:  MOVF   47,W
0671:  BSF    03.5
0672:  MOVWF  2D
0673:  BCF    03.5
0674:  MOVF   43,W
0675:  BTFSS  03.0
0676:  INCFSZ 43,W
0677:  GOTO   679
0678:  GOTO   67C
0679:  BSF    03.5
067A:  SUBWF  2D,F
067B:  BCF    03.5
067C:  MOVF   48,W
067D:  BSF    03.5
067E:  MOVWF  2E
067F:  BCF    03.5
0680:  MOVF   44,W
0681:  BTFSS  03.0
0682:  INCFSZ 44,W
0683:  GOTO   685
0684:  GOTO   688
0685:  BSF    03.5
0686:  SUBWF  2E,F
0687:  BCF    03.5
0688:  BSF    03.5
0689:  MOVF   2D,W
068A:  MOVWF  33
068B:  MOVF   2C,W
068C:  MOVWF  32
068D:  MOVF   2B,W
068E:  MOVWF  31
068F:  CLRF   30
0690:  BCF    03.5
0691:  MOVF   39,W
0692:  SUBWF  3D,W
0693:  MOVWF  77
0694:  MOVF   3E,W
0695:  MOVWF  78
0696:  MOVF   3A,W
0697:  BTFSS  03.0
0698:  INCFSZ 3A,W
0699:  SUBWF  78,F
069A:  MOVF   3F,W
069B:  MOVWF  79
069C:  MOVF   3B,W
069D:  BTFSS  03.0
069E:  INCFSZ 3B,W
069F:  SUBWF  79,F
06A0:  MOVF   40,W
06A1:  MOVWF  7A
06A2:  MOVF   3C,W
06A3:  BTFSS  03.0
06A4:  INCFSZ 3C,W
06A5:  SUBWF  7A,F
06A6:  MOVF   7A,W
06A7:  BSF    03.5
06A8:  MOVWF  37
06A9:  MOVF   79,W
06AA:  MOVWF  36
06AB:  MOVF   78,W
06AC:  MOVWF  35
06AD:  MOVF   77,W
06AE:  MOVWF  34
06AF:  MOVF   2D,W
06B0:  MOVWF  3B
06B1:  MOVF   2C,W
06B2:  MOVWF  3A
06B3:  MOVF   2B,W
06B4:  MOVWF  39
06B5:  MOVF   30,W
06B6:  MOVWF  38
06B7:  MOVF   37,W
06B8:  MOVWF  3F
06B9:  MOVF   36,W
06BA:  MOVWF  3E
06BB:  MOVF   35,W
06BC:  MOVWF  3D
06BD:  MOVF   34,W
06BE:  MOVWF  3C
06BF:  BCF    03.5
06C0:  BCF    03.6
06C1:  CALL   452
06C2:  MOVF   7A,W
06C3:  BSF    03.5
06C4:  BSF    03.6
06C5:  MOVWF  34
06C6:  MOVF   79,W
06C7:  MOVWF  33
06C8:  MOVF   78,W
06C9:  MOVWF  32
06CA:  MOVF   77,W
06CB:  MOVWF  31
06CC:  MOVF   2A,W
06CD:  MOVWF  38
06CE:  MOVF   29,W
06CF:  MOVWF  37
06D0:  MOVF   28,W
06D1:  MOVWF  36
06D2:  MOVF   27,W
06D3:  MOVWF  35
06D4:  MOVF   34,W
06D5:  MOVWF  3C
06D6:  MOVF   33,W
06D7:  MOVWF  3B
06D8:  MOVF   32,W
06D9:  MOVWF  3A
06DA:  MOVF   31,W
06DB:  MOVWF  39
06DC:  BCF    03.5
06DD:  BCF    03.6
06DE:  CALL   424
06DF:  MOVF   77,W
06E0:  BSF    03.5
06E1:  BSF    03.6
06E2:  MOVWF  28
06E3:  COMF   28,F
06E4:  MOVF   78,W
06E5:  MOVWF  29
06E6:  COMF   29,F
06E7:  MOVF   79,W
06E8:  MOVWF  2A
06E9:  COMF   2A,F
06EA:  MOVF   7A,W
06EB:  MOVWF  2B
06EC:  COMF   2B,F
06ED:  MOVF   29,W
06EE:  MOVWF  77
06EF:  MOVF   2A,W
06F0:  MOVWF  78
06F1:  MOVF   2B,W
06F2:  MOVWF  79
06F3:  CLRF   7A
06F4:  COMF   77,F
06F5:  COMF   78,F
06F6:  COMF   79,F
06F7:  COMF   7A,F
06F8:  MOVF   77,W
06F9:  BCF    03.5
06FA:  ADDWF  41,W
06FB:  MOVWF  49
06FC:  MOVF   42,W
06FD:  MOVWF  4A
06FE:  MOVF   78,W
06FF:  BTFSC  03.0
0700:  INCFSZ 78,W
0701:  ADDWF  4A,F
0702:  MOVF   43,W
0703:  MOVWF  4B
0704:  MOVF   79,W
0705:  BTFSC  03.0
0706:  INCFSZ 79,W
0707:  ADDWF  4B,F
0708:  MOVF   44,W
0709:  MOVWF  4C
070A:  MOVF   7A,W
070B:  BTFSC  03.0
070C:  INCFSZ 7A,W
070D:  ADDWF  4C,F
....................    Yout=DD(Yout,Q); 
070E:  BTFSC  4C.7
070F:  GOTO   718
0710:  MOVF   4A,W
0711:  MOVWF  77
0712:  MOVF   4B,W
0713:  MOVWF  78
0714:  MOVF   4C,W
0715:  MOVWF  79
0716:  CLRF   7A
0717:  GOTO   737
0718:  MOVF   49,W
0719:  BSF    03.5
071A:  MOVWF  11
071B:  COMF   11,F
071C:  BCF    03.5
071D:  MOVF   4A,W
071E:  BSF    03.5
071F:  MOVWF  12
0720:  COMF   12,F
0721:  BCF    03.5
0722:  MOVF   4B,W
0723:  BSF    03.5
0724:  MOVWF  13
0725:  COMF   13,F
0726:  BCF    03.5
0727:  MOVF   4C,W
0728:  BSF    03.5
0729:  MOVWF  14
072A:  COMF   14,F
072B:  MOVF   12,W
072C:  MOVWF  77
072D:  MOVF   13,W
072E:  MOVWF  78
072F:  MOVF   14,W
0730:  MOVWF  79
0731:  CLRF   7A
0732:  COMF   77,F
0733:  COMF   78,F
0734:  COMF   79,F
0735:  COMF   7A,F
0736:  BCF    03.5
0737:  MOVF   7A,W
0738:  MOVWF  4C
0739:  MOVF   79,W
073A:  MOVWF  4B
073B:  MOVF   78,W
073C:  MOVWF  4A
073D:  MOVF   77,W
073E:  MOVWF  49
....................    return Yout; 
073F:  MOVF   49,W
0740:  MOVWF  77
0741:  MOVF   4A,W
0742:  MOVWF  78
0743:  MOVF   4B,W
0744:  MOVWF  79
0745:  MOVF   4C,W
0746:  MOVWF  7A
.................... } 
0747:  BCF    03.6
0748:  RETLW  00
....................  
....................  
.................... // GdeZ: Funcion transferencia en el dominio Z  <<< G[z] >>>. 
.................... // ===== 
.................... // Recibe: un vector de coeficientes         b[m]      Long: M+1 
.................... //         un vector de coeficientes         a[n]      Long: N+1 
.................... //         un vector de entradas temporales  u          
.................... //         un vector de salidas anteriores   y          
.................... //         grado del polinomio (valor de M) 
.................... //         grado del polinomio (valor de N) 
.................... // Retorna: salida del sistema 
.................... //------------------------------------------------------------------------------------ 
.................... // En n (tiempo discreto): 
.................... // 
.................... //  y[k] = b[0]*u[k] + b[1]*u[k-1] + ... + b[m]*u[k-m]-a[1]*y[k-1] - ... - a[n]*y[k-n] 
.................... // 
.................... //  Siendo: u[m] las entradas temporales 
.................... //          y[n] las salidas temporales 
.................... // 
.................... // 
.................... // En Z (plano Z): 
.................... // 
.................... //          Y[z]    b0 + b1.z^-1 + b2.z^-2 + ... + bm.z^-m 
.................... //  G[z] = ----- = ---------------------------------------- 
.................... //          U[z]    1 + a1.z^-1 + a2.z^-2 + ... + an.z^-n 
.................... // 
.................... //  Siendo: U[z] las entradas transformadas 
.................... //          Y[z] las salidas transformadas 
.................... // 
.................... g GdeZ(g uk[],g bk[],int m, g yk[],g ak[],int n) 
.................... {  
....................    g primero,segundo,out; 
....................     
....................    primero=ProdEsc_FP(uk,bk,m); 
*
079C:  BSF    03.6
079D:  MOVF   2D,W
079E:  MOVWF  43
079F:  MOVF   2C,W
07A0:  MOVWF  42
07A1:  MOVF   2F,W
07A2:  MOVWF  45
07A3:  MOVF   2E,W
07A4:  MOVWF  44
07A5:  MOVF   30,W
07A6:  MOVWF  46
07A7:  BSF    0A.3
07A8:  BCF    03.6
07A9:  CALL   000
07AA:  BCF    0A.3
07AB:  MOVF   7A,W
07AC:  BSF    03.6
07AD:  MOVWF  39
07AE:  MOVF   79,W
07AF:  MOVWF  38
07B0:  MOVF   78,W
07B1:  MOVWF  37
07B2:  MOVF   77,W
07B3:  MOVWF  36
....................    segundo=ProdEsc_FP(yk,ak,n);  // los coeficientes de segundo, se restan 
07B4:  MOVF   32,W
07B5:  MOVWF  43
07B6:  MOVF   31,W
07B7:  MOVWF  42
07B8:  MOVF   34,W
07B9:  MOVWF  45
07BA:  MOVF   33,W
07BB:  MOVWF  44
07BC:  MOVF   35,W
07BD:  MOVWF  46
07BE:  BSF    0A.3
07BF:  BCF    03.6
07C0:  CALL   000
07C1:  BCF    0A.3
07C2:  MOVF   7A,W
07C3:  BSF    03.6
07C4:  MOVWF  3D
07C5:  MOVF   79,W
07C6:  MOVWF  3C
07C7:  MOVF   78,W
07C8:  MOVWF  3B
07C9:  MOVF   77,W
07CA:  MOVWF  3A
....................    out=primero-segundo; 
07CB:  MOVF   3A,W
07CC:  SUBWF  36,W
07CD:  MOVWF  3E
07CE:  MOVF   37,W
07CF:  MOVWF  3F
07D0:  MOVF   3B,W
07D1:  BTFSS  03.0
07D2:  INCFSZ 3B,W
07D3:  SUBWF  3F,F
07D4:  MOVF   38,W
07D5:  MOVWF  40
07D6:  MOVF   3C,W
07D7:  BTFSS  03.0
07D8:  INCFSZ 3C,W
07D9:  SUBWF  40,F
07DA:  MOVF   39,W
07DB:  MOVWF  41
07DC:  MOVF   3D,W
07DD:  BTFSS  03.0
07DE:  INCFSZ 3D,W
07DF:  SUBWF  41,F
....................    return out;  
07E0:  MOVF   3E,W
07E1:  MOVWF  77
07E2:  MOVF   3F,W
07E3:  MOVWF  78
07E4:  MOVF   40,W
07E5:  MOVWF  79
07E6:  MOVF   41,W
07E7:  MOVWF  7A
.................... } 
07E8:  BCF    03.6
07E9:  RETLW  00
....................  
....................  
.................... // FUNCIONES DE CONTROL // 
.................... // ====================== 
.................... //Velocidad 
.................... void velocidad(void) 
.................... {   g volt; 
....................     set_adc_channel(0); 
*
0D9F:  MOVLW  00
0DA0:  MOVWF  78
0DA1:  MOVF   1F,W
0DA2:  ANDLW  C7
0DA3:  IORWF  78,W
0DA4:  MOVWF  1F
....................     velact=Read_ADC(); 
0DA5:  BSF    1F.2
0DA6:  BTFSC  1F.2
0DA7:  GOTO   5A6
0DA8:  MOVF   1E,W
0DA9:  MOVWF  7A
0DAA:  BSF    03.5
0DAB:  MOVF   7A,W
0DAC:  MOVWF  78
0DAD:  CLRF   79
0DAE:  CLRF   7A
0DAF:  MOVF   7A,W
0DB0:  MOVWF  23
0DB1:  MOVF   79,W
0DB2:  MOVWF  22
0DB3:  MOVF   78,W
0DB4:  MOVWF  21
0DB5:  MOVF   1E,W
0DB6:  MOVWF  20
....................     delay_us(ESPERA); 
0DB7:  MOVLW  0D
0DB8:  MOVWF  77
0DB9:  DECFSZ 77,F
0DBA:  GOTO   5B9
....................     //interpolacion para obtener la vel actual en rpm 
....................     velrpm=lineal_FP(FP(velact,Q),(g)FP(200,Q),(g)FP(823,Q),(g)FP(-62,Q),(g)FP(62,Q)); 
0DBB:  MOVF   23,W
0DBC:  BSF    03.6
0DBD:  MOVWF  38
0DBE:  BCF    03.6
0DBF:  MOVF   22,W
0DC0:  BSF    03.6
0DC1:  MOVWF  37
0DC2:  BCF    03.6
0DC3:  MOVF   21,W
0DC4:  BSF    03.6
0DC5:  MOVWF  36
0DC6:  BCF    03.6
0DC7:  MOVF   20,W
0DC8:  BSF    03.6
0DC9:  MOVWF  35
0DCA:  CLRF   3C
0DCB:  CLRF   3B
0DCC:  MOVLW  01
0DCD:  MOVWF  3A
0DCE:  CLRF   39
0DCF:  BCF    0A.3
0DD0:  BCF    03.5
0DD1:  BCF    03.6
0DD2:  CALL   424
0DD3:  BSF    0A.3
0DD4:  MOVF   7A,W
0DD5:  BSF    03.6
0DD6:  MOVWF  30
0DD7:  MOVF   79,W
0DD8:  MOVWF  2F
0DD9:  MOVF   78,W
0DDA:  MOVWF  2E
0DDB:  MOVF   77,W
0DDC:  MOVWF  2D
0DDD:  MOVF   30,W
0DDE:  MOVWF  38
0DDF:  MOVF   2F,W
0DE0:  MOVWF  37
0DE1:  MOVF   2E,W
0DE2:  MOVWF  36
0DE3:  MOVF   2D,W
0DE4:  MOVWF  35
0DE5:  CLRF   3C
0DE6:  CLRF   3B
0DE7:  MOVLW  C8
0DE8:  MOVWF  3A
0DE9:  CLRF   39
0DEA:  CLRF   40
0DEB:  MOVLW  03
0DEC:  MOVWF  3F
0DED:  MOVLW  37
0DEE:  MOVWF  3E
0DEF:  CLRF   3D
0DF0:  MOVLW  FF
0DF1:  MOVWF  44
0DF2:  MOVWF  43
0DF3:  MOVLW  C2
0DF4:  MOVWF  42
0DF5:  CLRF   41
0DF6:  CLRF   48
0DF7:  CLRF   47
0DF8:  MOVLW  3E
0DF9:  MOVWF  46
0DFA:  CLRF   45
0DFB:  BCF    0A.3
0DFC:  BCF    03.6
0DFD:  CALL   4C3
0DFE:  BSF    0A.3
0DFF:  MOVF   7A,W
0E00:  BSF    03.5
0E01:  MOVWF  27
0E02:  MOVF   79,W
0E03:  MOVWF  26
0E04:  MOVF   78,W
0E05:  MOVWF  25
0E06:  MOVF   77,W
0E07:  MOVWF  24
....................       
....................    if(modo==3) 
0E08:  BCF    03.5
0E09:  MOVF   30,W
0E0A:  SUBLW  03
0E0B:  BTFSS  03.2
0E0C:  GOTO   679
....................       {  set_adc_channel(1); 
0E0D:  MOVLW  08
0E0E:  MOVWF  78
0E0F:  MOVF   1F,W
0E10:  ANDLW  C7
0E11:  IORWF  78,W
0E12:  MOVWF  1F
....................          delay_us(ESPERA);  
0E13:  MOVLW  0D
0E14:  MOVWF  77
0E15:  DECFSZ 77,F
0E16:  GOTO   615
....................          refevel=READ_ADC(); 
0E17:  BSF    1F.2
0E18:  BTFSC  1F.2
0E19:  GOTO   618
0E1A:  MOVF   1E,W
0E1B:  MOVWF  7A
0E1C:  BSF    03.5
0E1D:  MOVF   7A,W
0E1E:  MOVWF  78
0E1F:  CLRF   79
0E20:  CLRF   7A
0E21:  MOVF   7A,W
0E22:  MOVWF  2B
0E23:  MOVF   79,W
0E24:  MOVWF  2A
0E25:  MOVF   78,W
0E26:  MOVWF  29
0E27:  MOVF   1E,W
0E28:  MOVWF  28
....................          delay_us(ESPERA); 
0E29:  MOVLW  0D
0E2A:  MOVWF  77
0E2B:  DECFSZ 77,F
0E2C:  GOTO   62B
....................          velrefrpm=lineal_FP(FP(refevel,Q),(g)FP(31,Q),(g)FP(997,Q),(g)FP(-90,Q),(g)FP(90,Q)); 
0E2D:  MOVF   2B,W
0E2E:  BSF    03.6
0E2F:  MOVWF  38
0E30:  BCF    03.6
0E31:  MOVF   2A,W
0E32:  BSF    03.6
0E33:  MOVWF  37
0E34:  BCF    03.6
0E35:  MOVF   29,W
0E36:  BSF    03.6
0E37:  MOVWF  36
0E38:  BCF    03.6
0E39:  MOVF   28,W
0E3A:  BSF    03.6
0E3B:  MOVWF  35
0E3C:  CLRF   3C
0E3D:  CLRF   3B
0E3E:  MOVLW  01
0E3F:  MOVWF  3A
0E40:  CLRF   39
0E41:  BCF    0A.3
0E42:  BCF    03.5
0E43:  BCF    03.6
0E44:  CALL   424
0E45:  BSF    0A.3
0E46:  MOVF   7A,W
0E47:  BSF    03.6
0E48:  MOVWF  30
0E49:  MOVF   79,W
0E4A:  MOVWF  2F
0E4B:  MOVF   78,W
0E4C:  MOVWF  2E
0E4D:  MOVF   77,W
0E4E:  MOVWF  2D
0E4F:  MOVF   30,W
0E50:  MOVWF  38
0E51:  MOVF   2F,W
0E52:  MOVWF  37
0E53:  MOVF   2E,W
0E54:  MOVWF  36
0E55:  MOVF   2D,W
0E56:  MOVWF  35
0E57:  CLRF   3C
0E58:  CLRF   3B
0E59:  MOVLW  1F
0E5A:  MOVWF  3A
0E5B:  CLRF   39
0E5C:  CLRF   40
0E5D:  MOVLW  03
0E5E:  MOVWF  3F
0E5F:  MOVLW  E5
0E60:  MOVWF  3E
0E61:  CLRF   3D
0E62:  MOVLW  FF
0E63:  MOVWF  44
0E64:  MOVWF  43
0E65:  MOVLW  A6
0E66:  MOVWF  42
0E67:  CLRF   41
0E68:  CLRF   48
0E69:  CLRF   47
0E6A:  MOVLW  5A
0E6B:  MOVWF  46
0E6C:  CLRF   45
0E6D:  BCF    0A.3
0E6E:  BCF    03.6
0E6F:  CALL   4C3
0E70:  BSF    0A.3
0E71:  MOVF   7A,W
0E72:  MOVWF  76
0E73:  MOVF   79,W
0E74:  MOVWF  75
0E75:  MOVF   78,W
0E76:  MOVWF  74
0E77:  MOVF   77,W
0E78:  MOVWF  73
....................        ///printf("\n\r velrefrpm    %ld \r",velrefrpm); 
....................       } 
....................  
....................    enuevo=velrefrpm-velrpm;   //calculo del error 
0E79:  BSF    03.5
0E7A:  MOVF   24,W
0E7B:  SUBWF  73,W
0E7C:  BCF    03.5
0E7D:  MOVWF  4F
0E7E:  MOVF   74,W
0E7F:  MOVWF  50
0E80:  BSF    03.5
0E81:  MOVF   25,W
0E82:  BTFSS  03.0
0E83:  INCFSZ 25,W
0E84:  GOTO   686
0E85:  GOTO   689
0E86:  BCF    03.5
0E87:  SUBWF  50,F
0E88:  BSF    03.5
0E89:  MOVF   75,W
0E8A:  BCF    03.5
0E8B:  MOVWF  51
0E8C:  BSF    03.5
0E8D:  MOVF   26,W
0E8E:  BTFSS  03.0
0E8F:  INCFSZ 26,W
0E90:  GOTO   692
0E91:  GOTO   695
0E92:  BCF    03.5
0E93:  SUBWF  51,F
0E94:  BSF    03.5
0E95:  MOVF   76,W
0E96:  BCF    03.5
0E97:  MOVWF  52
0E98:  BSF    03.5
0E99:  MOVF   27,W
0E9A:  BTFSS  03.0
0E9B:  INCFSZ 27,W
0E9C:  GOTO   69E
0E9D:  GOTO   6A1
0E9E:  BCF    03.5
0E9F:  SUBWF  52,F
0EA0:  BSF    03.5
....................    ///  printf("\n\r velrefrpm   -velrpm    %ld      %ld    %ld \r",velrefrpm,velrpm, velact); 
....................    enuevo=FP(enuevo,Q); 
0EA1:  BCF    03.5
0EA2:  MOVF   52,W
0EA3:  BSF    03.5
0EA4:  BSF    03.6
0EA5:  MOVWF  38
0EA6:  BCF    03.5
0EA7:  BCF    03.6
0EA8:  MOVF   51,W
0EA9:  BSF    03.5
0EAA:  BSF    03.6
0EAB:  MOVWF  37
0EAC:  BCF    03.5
0EAD:  BCF    03.6
0EAE:  MOVF   50,W
0EAF:  BSF    03.5
0EB0:  BSF    03.6
0EB1:  MOVWF  36
0EB2:  BCF    03.5
0EB3:  BCF    03.6
0EB4:  MOVF   4F,W
0EB5:  BSF    03.5
0EB6:  BSF    03.6
0EB7:  MOVWF  35
0EB8:  CLRF   3C
0EB9:  CLRF   3B
0EBA:  MOVLW  01
0EBB:  MOVWF  3A
0EBC:  CLRF   39
0EBD:  BCF    0A.3
0EBE:  BCF    03.5
0EBF:  BCF    03.6
0EC0:  CALL   424
0EC1:  BSF    0A.3
0EC2:  MOVF   7A,W
0EC3:  MOVWF  52
0EC4:  MOVF   79,W
0EC5:  MOVWF  51
0EC6:  MOVF   78,W
0EC7:  MOVWF  50
0EC8:  MOVF   77,W
0EC9:  MOVWF  4F
....................     cola_FP(errovel,MVEL+1,enuevo); 
0ECA:  BSF    03.6
0ECB:  CLRF   2D
0ECC:  MOVLW  AC
0ECD:  MOVWF  2C
0ECE:  MOVLW  02
0ECF:  MOVWF  2E
0ED0:  BCF    03.6
0ED1:  MOVF   52,W
0ED2:  BSF    03.6
0ED3:  MOVWF  32
0ED4:  BCF    03.6
0ED5:  MOVF   51,W
0ED6:  BSF    03.6
0ED7:  MOVWF  31
0ED8:  BCF    03.6
0ED9:  MOVF   50,W
0EDA:  BSF    03.6
0EDB:  MOVWF  30
0EDC:  BCF    03.6
0EDD:  MOVF   4F,W
0EDE:  BSF    03.6
0EDF:  MOVWF  2F
0EE0:  BCF    0A.3
0EE1:  BCF    03.6
0EE2:  CALL   749
0EE3:  BSF    0A.3
....................     cola_FP(ukvel,NVEL+1,0); 
0EE4:  BSF    03.6
0EE5:  CLRF   2D
0EE6:  MOVLW  B4
0EE7:  MOVWF  2C
0EE8:  MOVLW  02
0EE9:  MOVWF  2E
0EEA:  CLRF   32
0EEB:  CLRF   31
0EEC:  CLRF   30
0EED:  CLRF   2F
0EEE:  BCF    0A.3
0EEF:  BCF    03.6
0EF0:  CALL   749
0EF1:  BSF    0A.3
....................     
....................     ukvel[0]= GdeZ(errovel,bvel,MVEL+1, ukvel, avel, NVEL+1); 
0EF2:  BSF    03.6
0EF3:  CLRF   2D
0EF4:  MOVLW  AC
0EF5:  MOVWF  2C
0EF6:  CLRF   2F
0EF7:  MOVLW  63
0EF8:  MOVWF  2E
0EF9:  MOVLW  02
0EFA:  MOVWF  30
0EFB:  CLRF   32
0EFC:  MOVLW  B4
0EFD:  MOVWF  31
0EFE:  CLRF   34
0EFF:  MOVLW  6B
0F00:  MOVWF  33
0F01:  MOVLW  02
0F02:  MOVWF  35
0F03:  BCF    0A.3
0F04:  BCF    03.6
0F05:  CALL   79C
0F06:  BSF    0A.3
0F07:  MOVF   7A,W
0F08:  BSF    03.5
0F09:  MOVWF  37
0F0A:  MOVF   79,W
0F0B:  MOVWF  36
0F0C:  MOVF   78,W
0F0D:  MOVWF  35
0F0E:  MOVF   77,W
0F0F:  MOVWF  34
....................     volt = lineal_FP(ukvel[0],FP(18,Q),FP(-18,Q),FP(20,Q),FP(1003,Q)); 
0F10:  MOVF   37,W
0F11:  BCF    03.5
0F12:  BSF    03.6
0F13:  MOVWF  38
0F14:  BSF    03.5
0F15:  BCF    03.6
0F16:  MOVF   36,W
0F17:  BCF    03.5
0F18:  BSF    03.6
0F19:  MOVWF  37
0F1A:  BSF    03.5
0F1B:  BCF    03.6
0F1C:  MOVF   35,W
0F1D:  BCF    03.5
0F1E:  BSF    03.6
0F1F:  MOVWF  36
0F20:  BSF    03.5
0F21:  BCF    03.6
0F22:  MOVF   34,W
0F23:  BCF    03.5
0F24:  BSF    03.6
0F25:  MOVWF  35
0F26:  CLRF   3C
0F27:  CLRF   3B
0F28:  MOVLW  12
0F29:  MOVWF  3A
0F2A:  CLRF   39
0F2B:  MOVLW  FF
0F2C:  MOVWF  40
0F2D:  MOVWF  3F
0F2E:  MOVLW  EE
0F2F:  MOVWF  3E
0F30:  CLRF   3D
0F31:  CLRF   44
0F32:  CLRF   43
0F33:  MOVLW  14
0F34:  MOVWF  42
0F35:  CLRF   41
0F36:  CLRF   48
0F37:  MOVLW  03
0F38:  MOVWF  47
0F39:  MOVLW  EB
0F3A:  MOVWF  46
0F3B:  CLRF   45
0F3C:  BCF    0A.3
0F3D:  BCF    03.6
0F3E:  CALL   4C3
0F3F:  BSF    0A.3
0F40:  MOVF   7A,W
0F41:  BSF    03.6
0F42:  MOVWF  2B
0F43:  MOVF   79,W
0F44:  MOVWF  2A
0F45:  MOVF   78,W
0F46:  MOVWF  29
0F47:  MOVF   77,W
0F48:  MOVWF  28
....................     
....................    ///printf("\n\r UKVEL(0)   VOLT    %ld      %ld    \r",ukvel[0],volt); 
....................  
....................     if (volt>=1003)      //limitaciones del PWM 
0F49:  BTFSC  2B.7
0F4A:  GOTO   762
0F4B:  MOVF   2B,F
0F4C:  BTFSS  03.2
0F4D:  GOTO   75C
0F4E:  MOVF   2A,F
0F4F:  BTFSS  03.2
0F50:  GOTO   75C
0F51:  MOVF   29,W
0F52:  SUBLW  02
0F53:  BTFSC  03.0
0F54:  GOTO   762
0F55:  XORLW  FF
0F56:  BTFSS  03.2
0F57:  GOTO   75C
0F58:  MOVF   28,W
0F59:  SUBLW  EA
0F5A:  BTFSC  03.0
0F5B:  GOTO   762
....................          volt=1003; 
0F5C:  CLRF   2B
0F5D:  CLRF   2A
0F5E:  MOVLW  03
0F5F:  MOVWF  29
0F60:  MOVLW  EB
0F61:  MOVWF  28
....................     if (volt<=20) 
0F62:  BTFSC  2B.7
0F63:  GOTO   771
0F64:  MOVF   2B,F
0F65:  BTFSS  03.2
0F66:  GOTO   776
0F67:  MOVF   2A,F
0F68:  BTFSS  03.2
0F69:  GOTO   776
0F6A:  MOVF   29,F
0F6B:  BTFSS  03.2
0F6C:  GOTO   776
0F6D:  MOVF   28,W
0F6E:  SUBLW  14
0F6F:  BTFSS  03.0
0F70:  GOTO   776
....................          volt=20; 
0F71:  CLRF   2B
0F72:  CLRF   2A
0F73:  CLRF   29
0F74:  MOVLW  14
0F75:  MOVWF  28
....................  
....................     set_pwm1_duty(volt);  
0F76:  MOVF   29,W
0F77:  MOVWF  79
0F78:  MOVF   28,W
0F79:  MOVWF  78
0F7A:  RRF    79,F
0F7B:  RRF    78,F
0F7C:  RRF    79,F
0F7D:  RRF    78,F
0F7E:  RRF    79,F
0F7F:  MOVF   78,W
0F80:  BCF    03.6
0F81:  MOVWF  15
0F82:  RRF    79,F
0F83:  RRF    79,W
0F84:  ANDLW  30
0F85:  MOVWF  77
0F86:  MOVF   17,W
0F87:  ANDLW  CF
0F88:  IORWF  77,W
0F89:  MOVWF  17
.................... } 
0F8A:  RETLW  00
....................  
....................  
.................... //Posicion 
.................... void posicion(void) 
.................... {  g volt; 
....................    set_adc_channel(2); 
*
0986:  MOVLW  10
0987:  MOVWF  78
0988:  MOVF   1F,W
0989:  ANDLW  C7
098A:  IORWF  78,W
098B:  MOVWF  1F
....................    posact=Read_ADC(); 
098C:  BSF    1F.2
098D:  BTFSC  1F.2
098E:  GOTO   18D
098F:  MOVF   1E,W
0990:  MOVWF  7A
0991:  BSF    03.5
0992:  MOVF   7A,W
0993:  MOVWF  78
0994:  CLRF   79
0995:  CLRF   7A
0996:  MOVF   7A,W
0997:  MOVWF  4F
0998:  MOVF   79,W
0999:  MOVWF  4E
099A:  MOVF   78,W
099B:  MOVWF  4D
099C:  MOVF   1E,W
099D:  MOVWF  4C
....................    delay_us(ESPERA); 
099E:  MOVLW  0D
099F:  MOVWF  77
09A0:  DECFSZ 77,F
09A1:  GOTO   1A0
....................    if (modo==2)  //POS TECLADO 
09A2:  BCF    03.5
09A3:  MOVF   30,W
09A4:  SUBLW  02
09A5:  BTFSS  03.2
09A6:  GOTO   1F5
....................       posgr=lineal_FP(FP(posact,Q),(g)FP(40,Q),(g)FP(1020,Q),(g)FP(0,Q),(g)FP(360,Q)); 
09A7:  BSF    03.5
09A8:  MOVF   4F,W
09A9:  BSF    03.6
09AA:  MOVWF  38
09AB:  BCF    03.6
09AC:  MOVF   4E,W
09AD:  BSF    03.6
09AE:  MOVWF  37
09AF:  BCF    03.6
09B0:  MOVF   4D,W
09B1:  BSF    03.6
09B2:  MOVWF  36
09B3:  BCF    03.6
09B4:  MOVF   4C,W
09B5:  BSF    03.6
09B6:  MOVWF  35
09B7:  CLRF   3C
09B8:  CLRF   3B
09B9:  MOVLW  01
09BA:  MOVWF  3A
09BB:  CLRF   39
09BC:  BCF    0A.3
09BD:  BCF    03.5
09BE:  BCF    03.6
09BF:  CALL   424
09C0:  BSF    0A.3
09C1:  MOVF   7A,W
09C2:  BSF    03.6
09C3:  MOVWF  30
09C4:  MOVF   79,W
09C5:  MOVWF  2F
09C6:  MOVF   78,W
09C7:  MOVWF  2E
09C8:  MOVF   77,W
09C9:  MOVWF  2D
09CA:  MOVF   30,W
09CB:  MOVWF  38
09CC:  MOVF   2F,W
09CD:  MOVWF  37
09CE:  MOVF   2E,W
09CF:  MOVWF  36
09D0:  MOVF   2D,W
09D1:  MOVWF  35
09D2:  CLRF   3C
09D3:  CLRF   3B
09D4:  MOVLW  28
09D5:  MOVWF  3A
09D6:  CLRF   39
09D7:  CLRF   40
09D8:  MOVLW  03
09D9:  MOVWF  3F
09DA:  MOVLW  FC
09DB:  MOVWF  3E
09DC:  CLRF   3D
09DD:  CLRF   44
09DE:  CLRF   43
09DF:  CLRF   42
09E0:  CLRF   41
09E1:  CLRF   48
09E2:  MOVLW  01
09E3:  MOVWF  47
09E4:  MOVLW  68
09E5:  MOVWF  46
09E6:  CLRF   45
09E7:  BCF    0A.3
09E8:  BCF    03.6
09E9:  CALL   4C3
09EA:  BSF    0A.3
09EB:  MOVF   7A,W
09EC:  BSF    03.5
09ED:  MOVWF  53
09EE:  MOVF   79,W
09EF:  MOVWF  52
09F0:  MOVF   78,W
09F1:  MOVWF  51
09F2:  MOVF   77,W
09F3:  MOVWF  50
09F4:  BCF    03.5
....................    if (modo==4)   //POS POTE 
09F5:  MOVF   30,W
09F6:  SUBLW  04
09F7:  BTFSS  03.2
09F8:  GOTO   248
....................       posgr=lineal_FP(FP(posact,Q),(g)FP(30,Q),(g)FP(993,Q),(g)FP(150,Q),(g)FP(-150,Q));  
09F9:  BSF    03.5
09FA:  MOVF   4F,W
09FB:  BSF    03.6
09FC:  MOVWF  38
09FD:  BCF    03.6
09FE:  MOVF   4E,W
09FF:  BSF    03.6
0A00:  MOVWF  37
0A01:  BCF    03.6
0A02:  MOVF   4D,W
0A03:  BSF    03.6
0A04:  MOVWF  36
0A05:  BCF    03.6
0A06:  MOVF   4C,W
0A07:  BSF    03.6
0A08:  MOVWF  35
0A09:  CLRF   3C
0A0A:  CLRF   3B
0A0B:  MOVLW  01
0A0C:  MOVWF  3A
0A0D:  CLRF   39
0A0E:  BCF    0A.3
0A0F:  BCF    03.5
0A10:  BCF    03.6
0A11:  CALL   424
0A12:  BSF    0A.3
0A13:  MOVF   7A,W
0A14:  BSF    03.6
0A15:  MOVWF  30
0A16:  MOVF   79,W
0A17:  MOVWF  2F
0A18:  MOVF   78,W
0A19:  MOVWF  2E
0A1A:  MOVF   77,W
0A1B:  MOVWF  2D
0A1C:  MOVF   30,W
0A1D:  MOVWF  38
0A1E:  MOVF   2F,W
0A1F:  MOVWF  37
0A20:  MOVF   2E,W
0A21:  MOVWF  36
0A22:  MOVF   2D,W
0A23:  MOVWF  35
0A24:  CLRF   3C
0A25:  CLRF   3B
0A26:  MOVLW  1E
0A27:  MOVWF  3A
0A28:  CLRF   39
0A29:  CLRF   40
0A2A:  MOVLW  03
0A2B:  MOVWF  3F
0A2C:  MOVLW  E1
0A2D:  MOVWF  3E
0A2E:  CLRF   3D
0A2F:  CLRF   44
0A30:  CLRF   43
0A31:  MOVLW  96
0A32:  MOVWF  42
0A33:  CLRF   41
0A34:  MOVLW  FF
0A35:  MOVWF  48
0A36:  MOVWF  47
0A37:  MOVLW  6A
0A38:  MOVWF  46
0A39:  CLRF   45
0A3A:  BCF    0A.3
0A3B:  BCF    03.6
0A3C:  CALL   4C3
0A3D:  BSF    0A.3
0A3E:  MOVF   7A,W
0A3F:  BSF    03.5
0A40:  MOVWF  53
0A41:  MOVF   79,W
0A42:  MOVWF  52
0A43:  MOVF   78,W
0A44:  MOVWF  51
0A45:  MOVF   77,W
0A46:  MOVWF  50
0A47:  BCF    03.5
....................    enuevo=posrefgr-posgr;               
0A48:  BSF    03.5
0A49:  MOVF   50,W
0A4A:  SUBWF  48,W
0A4B:  BCF    03.5
0A4C:  MOVWF  4F
0A4D:  BSF    03.5
0A4E:  MOVF   49,W
0A4F:  BCF    03.5
0A50:  MOVWF  50
0A51:  BSF    03.5
0A52:  MOVF   51,W
0A53:  BTFSS  03.0
0A54:  INCFSZ 51,W
0A55:  GOTO   257
0A56:  GOTO   25A
0A57:  BCF    03.5
0A58:  SUBWF  50,F
0A59:  BSF    03.5
0A5A:  MOVF   4A,W
0A5B:  BCF    03.5
0A5C:  MOVWF  51
0A5D:  BSF    03.5
0A5E:  MOVF   52,W
0A5F:  BTFSS  03.0
0A60:  INCFSZ 52,W
0A61:  GOTO   263
0A62:  GOTO   266
0A63:  BCF    03.5
0A64:  SUBWF  51,F
0A65:  BSF    03.5
0A66:  MOVF   4B,W
0A67:  BCF    03.5
0A68:  MOVWF  52
0A69:  BSF    03.5
0A6A:  MOVF   53,W
0A6B:  BTFSS  03.0
0A6C:  INCFSZ 53,W
0A6D:  GOTO   26F
0A6E:  GOTO   272
0A6F:  BCF    03.5
0A70:  SUBWF  52,F
0A71:  BSF    03.5
....................    enuevo=FP(enuevo,Q); 
0A72:  BCF    03.5
0A73:  MOVF   52,W
0A74:  BSF    03.5
0A75:  BSF    03.6
0A76:  MOVWF  38
0A77:  BCF    03.5
0A78:  BCF    03.6
0A79:  MOVF   51,W
0A7A:  BSF    03.5
0A7B:  BSF    03.6
0A7C:  MOVWF  37
0A7D:  BCF    03.5
0A7E:  BCF    03.6
0A7F:  MOVF   50,W
0A80:  BSF    03.5
0A81:  BSF    03.6
0A82:  MOVWF  36
0A83:  BCF    03.5
0A84:  BCF    03.6
0A85:  MOVF   4F,W
0A86:  BSF    03.5
0A87:  BSF    03.6
0A88:  MOVWF  35
0A89:  CLRF   3C
0A8A:  CLRF   3B
0A8B:  MOVLW  01
0A8C:  MOVWF  3A
0A8D:  CLRF   39
0A8E:  BCF    0A.3
0A8F:  BCF    03.5
0A90:  BCF    03.6
0A91:  CALL   424
0A92:  BSF    0A.3
0A93:  MOVF   7A,W
0A94:  MOVWF  52
0A95:  MOVF   79,W
0A96:  MOVWF  51
0A97:  MOVF   78,W
0A98:  MOVWF  50
0A99:  MOVF   77,W
0A9A:  MOVWF  4F
....................    cola_FP(erropos,MPOS+1,enuevo); 
0A9B:  BSF    03.6
0A9C:  CLRF   2D
0A9D:  MOVLW  D8
0A9E:  MOVWF  2C
0A9F:  MOVLW  02
0AA0:  MOVWF  2E
0AA1:  BCF    03.6
0AA2:  MOVF   52,W
0AA3:  BSF    03.6
0AA4:  MOVWF  32
0AA5:  BCF    03.6
0AA6:  MOVF   51,W
0AA7:  BSF    03.6
0AA8:  MOVWF  31
0AA9:  BCF    03.6
0AAA:  MOVF   50,W
0AAB:  BSF    03.6
0AAC:  MOVWF  30
0AAD:  BCF    03.6
0AAE:  MOVF   4F,W
0AAF:  BSF    03.6
0AB0:  MOVWF  2F
0AB1:  BCF    0A.3
0AB2:  BCF    03.6
0AB3:  CALL   749
0AB4:  BSF    0A.3
....................    cola_FP(ukpos,NPOS+1,0); 
0AB5:  BSF    03.6
0AB6:  CLRF   2D
0AB7:  MOVLW  E0
0AB8:  MOVWF  2C
0AB9:  MOVLW  01
0ABA:  MOVWF  2E
0ABB:  CLRF   32
0ABC:  CLRF   31
0ABD:  CLRF   30
0ABE:  CLRF   2F
0ABF:  BCF    0A.3
0AC0:  BCF    03.6
0AC1:  CALL   749
0AC2:  BSF    0A.3
....................  
....................    ukpos[0]= GdeZ(erropos,bpos,MPOS+1, ukpos, apos, NPOS+1); 
0AC3:  BSF    03.6
0AC4:  CLRF   2D
0AC5:  MOVLW  D8
0AC6:  MOVWF  2C
0AC7:  CLRF   2F
0AC8:  MOVLW  BC
0AC9:  MOVWF  2E
0ACA:  MOVLW  02
0ACB:  MOVWF  30
0ACC:  CLRF   32
0ACD:  MOVLW  E0
0ACE:  MOVWF  31
0ACF:  CLRF   34
0AD0:  MOVLW  C4
0AD1:  MOVWF  33
0AD2:  MOVLW  01
0AD3:  MOVWF  35
0AD4:  BCF    0A.3
0AD5:  BCF    03.6
0AD6:  CALL   79C
0AD7:  BSF    0A.3
0AD8:  MOVF   7A,W
0AD9:  BSF    03.5
0ADA:  MOVWF  63
0ADB:  MOVF   79,W
0ADC:  MOVWF  62
0ADD:  MOVF   78,W
0ADE:  MOVWF  61
0ADF:  MOVF   77,W
0AE0:  MOVWF  60
....................    if (modo==2) 
0AE1:  BCF    03.5
0AE2:  MOVF   30,W
0AE3:  SUBLW  02
0AE4:  BTFSS  03.2
0AE5:  GOTO   320
....................       volt = lineal_FP(ukpos[0],FP(18,Q),FP(-18,Q),FP(0,Q),FP(1023,Q)); 
0AE6:  BSF    03.5
0AE7:  MOVF   63,W
0AE8:  BCF    03.5
0AE9:  BSF    03.6
0AEA:  MOVWF  38
0AEB:  BSF    03.5
0AEC:  BCF    03.6
0AED:  MOVF   62,W
0AEE:  BCF    03.5
0AEF:  BSF    03.6
0AF0:  MOVWF  37
0AF1:  BSF    03.5
0AF2:  BCF    03.6
0AF3:  MOVF   61,W
0AF4:  BCF    03.5
0AF5:  BSF    03.6
0AF6:  MOVWF  36
0AF7:  BSF    03.5
0AF8:  BCF    03.6
0AF9:  MOVF   60,W
0AFA:  BCF    03.5
0AFB:  BSF    03.6
0AFC:  MOVWF  35
0AFD:  CLRF   3C
0AFE:  CLRF   3B
0AFF:  MOVLW  12
0B00:  MOVWF  3A
0B01:  CLRF   39
0B02:  MOVLW  FF
0B03:  MOVWF  40
0B04:  MOVWF  3F
0B05:  MOVLW  EE
0B06:  MOVWF  3E
0B07:  CLRF   3D
0B08:  CLRF   44
0B09:  CLRF   43
0B0A:  CLRF   42
0B0B:  CLRF   41
0B0C:  CLRF   48
0B0D:  MOVLW  03
0B0E:  MOVWF  47
0B0F:  MOVLW  FF
0B10:  MOVWF  46
0B11:  CLRF   45
0B12:  BCF    0A.3
0B13:  BCF    03.6
0B14:  CALL   4C3
0B15:  BSF    0A.3
0B16:  MOVF   7A,W
0B17:  BSF    03.6
0B18:  MOVWF  2B
0B19:  MOVF   79,W
0B1A:  MOVWF  2A
0B1B:  MOVF   78,W
0B1C:  MOVWF  29
0B1D:  MOVF   77,W
0B1E:  MOVWF  28
0B1F:  BCF    03.6
....................    if (modo==4) 
0B20:  MOVF   30,W
0B21:  SUBLW  04
0B22:  BTFSS  03.2
0B23:  GOTO   35E
....................       volt = lineal_FP(ukpos[0],FP(16,Q),FP(-20,Q),FP(1023,Q),FP(0,Q)); 
0B24:  BSF    03.5
0B25:  MOVF   63,W
0B26:  BCF    03.5
0B27:  BSF    03.6
0B28:  MOVWF  38
0B29:  BSF    03.5
0B2A:  BCF    03.6
0B2B:  MOVF   62,W
0B2C:  BCF    03.5
0B2D:  BSF    03.6
0B2E:  MOVWF  37
0B2F:  BSF    03.5
0B30:  BCF    03.6
0B31:  MOVF   61,W
0B32:  BCF    03.5
0B33:  BSF    03.6
0B34:  MOVWF  36
0B35:  BSF    03.5
0B36:  BCF    03.6
0B37:  MOVF   60,W
0B38:  BCF    03.5
0B39:  BSF    03.6
0B3A:  MOVWF  35
0B3B:  CLRF   3C
0B3C:  CLRF   3B
0B3D:  MOVLW  10
0B3E:  MOVWF  3A
0B3F:  CLRF   39
0B40:  MOVLW  FF
0B41:  MOVWF  40
0B42:  MOVWF  3F
0B43:  MOVLW  EC
0B44:  MOVWF  3E
0B45:  CLRF   3D
0B46:  CLRF   44
0B47:  MOVLW  03
0B48:  MOVWF  43
0B49:  MOVLW  FF
0B4A:  MOVWF  42
0B4B:  CLRF   41
0B4C:  CLRF   48
0B4D:  CLRF   47
0B4E:  CLRF   46
0B4F:  CLRF   45
0B50:  BCF    0A.3
0B51:  BCF    03.6
0B52:  CALL   4C3
0B53:  BSF    0A.3
0B54:  MOVF   7A,W
0B55:  BSF    03.6
0B56:  MOVWF  2B
0B57:  MOVF   79,W
0B58:  MOVWF  2A
0B59:  MOVF   78,W
0B5A:  MOVWF  29
0B5B:  MOVF   77,W
0B5C:  MOVWF  28
0B5D:  BCF    03.6
....................  
....................    if (volt>=1023) 
0B5E:  BSF    03.6
0B5F:  BTFSC  2B.7
0B60:  GOTO   378
0B61:  MOVF   2B,F
0B62:  BTFSS  03.2
0B63:  GOTO   372
0B64:  MOVF   2A,F
0B65:  BTFSS  03.2
0B66:  GOTO   372
0B67:  MOVF   29,W
0B68:  SUBLW  02
0B69:  BTFSC  03.0
0B6A:  GOTO   378
0B6B:  XORLW  FF
0B6C:  BTFSS  03.2
0B6D:  GOTO   372
0B6E:  MOVF   28,W
0B6F:  SUBLW  FE
0B70:  BTFSC  03.0
0B71:  GOTO   378
....................       volt=1023; 
0B72:  CLRF   2B
0B73:  CLRF   2A
0B74:  MOVLW  03
0B75:  MOVWF  29
0B76:  MOVLW  FF
0B77:  MOVWF  28
....................    if (volt<=20) 
0B78:  BTFSC  2B.7
0B79:  GOTO   387
0B7A:  MOVF   2B,F
0B7B:  BTFSS  03.2
0B7C:  GOTO   38C
0B7D:  MOVF   2A,F
0B7E:  BTFSS  03.2
0B7F:  GOTO   38C
0B80:  MOVF   29,F
0B81:  BTFSS  03.2
0B82:  GOTO   38C
0B83:  MOVF   28,W
0B84:  SUBLW  14
0B85:  BTFSS  03.0
0B86:  GOTO   38C
....................       volt=20; 
0B87:  CLRF   2B
0B88:  CLRF   2A
0B89:  CLRF   29
0B8A:  MOVLW  14
0B8B:  MOVWF  28
....................        
....................    set_pwm1_duty(volt);  
0B8C:  MOVF   29,W
0B8D:  MOVWF  79
0B8E:  MOVF   28,W
0B8F:  MOVWF  78
0B90:  RRF    79,F
0B91:  RRF    78,F
0B92:  RRF    79,F
0B93:  RRF    78,F
0B94:  RRF    79,F
0B95:  MOVF   78,W
0B96:  BCF    03.6
0B97:  MOVWF  15
0B98:  RRF    79,F
0B99:  RRF    79,W
0B9A:  ANDLW  30
0B9B:  MOVWF  77
0B9C:  MOVF   17,W
0B9D:  ANDLW  CF
0B9E:  IORWF  77,W
0B9F:  MOVWF  17
.................... } 
0BA0:  RETLW  00
....................  
.................... //Control de Velocidad con ingreso de referencia por teclado 
.................... void ContVel(void)    
.................... {    
....................    if((param==0)|(param==1))       //mantenemos el controlador disenado 
*
1420:  MOVF   7C,F
1421:  BTFSC  03.2
1422:  GOTO   425
1423:  MOVLW  00
1424:  GOTO   426
1425:  MOVLW  01
1426:  BSF    03.6
1427:  MOVWF  28
1428:  DECFSZ 7C,W
1429:  GOTO   42B
142A:  GOTO   42D
142B:  MOVLW  00
142C:  GOTO   42E
142D:  MOVLW  01
142E:  IORWF  28,W
142F:  BTFSC  03.2
1430:  GOTO   43E
....................    {  bvel[0]=B0_vel; 
1431:  BCF    03.6
1432:  CLRF   66
1433:  CLRF   65
1434:  CLRF   64
1435:  MOVLW  5C
1436:  MOVWF  63
....................       bvel[1]=B1_vel; 
1437:  MOVLW  FF
1438:  MOVWF  6A
1439:  MOVWF  69
143A:  MOVWF  68
143B:  MOVLW  AC
143C:  MOVWF  67
143D:  BSF    03.6
....................    } 
....................    if(param==1)               //en caso se desee cambiar los datos del controlador 
143E:  DECFSZ 7C,W
143F:  GOTO   4E2
....................    {  bvel[0]=FP(b0,Q);    
1440:  BCF    03.6
1441:  MOVF   5E,W
1442:  BSF    03.5
1443:  BSF    03.6
1444:  MOVWF  38
1445:  BCF    03.5
1446:  BCF    03.6
1447:  MOVF   5D,W
1448:  BSF    03.5
1449:  BSF    03.6
144A:  MOVWF  37
144B:  BCF    03.5
144C:  BCF    03.6
144D:  MOVF   5C,W
144E:  BSF    03.5
144F:  BSF    03.6
1450:  MOVWF  36
1451:  BCF    03.5
1452:  BCF    03.6
1453:  MOVF   5B,W
1454:  BSF    03.5
1455:  BSF    03.6
1456:  MOVWF  35
1457:  CLRF   3C
1458:  CLRF   3B
1459:  MOVLW  01
145A:  MOVWF  3A
145B:  CLRF   39
145C:  BCF    0A.4
145D:  BCF    03.5
145E:  BCF    03.6
145F:  CALL   424
1460:  BSF    0A.4
1461:  MOVF   7A,W
1462:  MOVWF  66
1463:  MOVF   79,W
1464:  MOVWF  65
1465:  MOVF   78,W
1466:  MOVWF  64
1467:  MOVF   77,W
1468:  MOVWF  63
....................       bvel[0]=bvel[0]/RES; 
1469:  MOVF   66,W
146A:  BSF    03.5
146B:  BSF    03.6
146C:  MOVWF  3B
146D:  BCF    03.5
146E:  BCF    03.6
146F:  MOVF   65,W
1470:  BSF    03.5
1471:  BSF    03.6
1472:  MOVWF  3A
1473:  BCF    03.5
1474:  BCF    03.6
1475:  MOVF   64,W
1476:  BSF    03.5
1477:  BSF    03.6
1478:  MOVWF  39
1479:  BCF    03.5
147A:  BCF    03.6
147B:  MOVF   63,W
147C:  BSF    03.5
147D:  BSF    03.6
147E:  MOVWF  38
147F:  CLRF   3F
1480:  CLRF   3E
1481:  CLRF   3D
1482:  MOVLW  64
1483:  MOVWF  3C
1484:  BCF    0A.4
1485:  BCF    03.5
1486:  BCF    03.6
1487:  CALL   452
1488:  BSF    0A.4
1489:  MOVF   7A,W
148A:  MOVWF  66
148B:  MOVF   79,W
148C:  MOVWF  65
148D:  MOVF   78,W
148E:  MOVWF  64
148F:  MOVF   77,W
1490:  MOVWF  63
....................       bvel[1]=FP(b1,Q); 
1491:  MOVF   62,W
1492:  BSF    03.5
1493:  BSF    03.6
1494:  MOVWF  38
1495:  BCF    03.5
1496:  BCF    03.6
1497:  MOVF   61,W
1498:  BSF    03.5
1499:  BSF    03.6
149A:  MOVWF  37
149B:  BCF    03.5
149C:  BCF    03.6
149D:  MOVF   60,W
149E:  BSF    03.5
149F:  BSF    03.6
14A0:  MOVWF  36
14A1:  BCF    03.5
14A2:  BCF    03.6
14A3:  MOVF   5F,W
14A4:  BSF    03.5
14A5:  BSF    03.6
14A6:  MOVWF  35
14A7:  CLRF   3C
14A8:  CLRF   3B
14A9:  MOVLW  01
14AA:  MOVWF  3A
14AB:  CLRF   39
14AC:  BCF    0A.4
14AD:  BCF    03.5
14AE:  BCF    03.6
14AF:  CALL   424
14B0:  BSF    0A.4
14B1:  MOVF   7A,W
14B2:  MOVWF  6A
14B3:  MOVF   79,W
14B4:  MOVWF  69
14B5:  MOVF   78,W
14B6:  MOVWF  68
14B7:  MOVF   77,W
14B8:  MOVWF  67
....................       bvel[1]=bvel[1]/RES; 
14B9:  MOVF   6A,W
14BA:  BSF    03.5
14BB:  BSF    03.6
14BC:  MOVWF  3B
14BD:  BCF    03.5
14BE:  BCF    03.6
14BF:  MOVF   69,W
14C0:  BSF    03.5
14C1:  BSF    03.6
14C2:  MOVWF  3A
14C3:  BCF    03.5
14C4:  BCF    03.6
14C5:  MOVF   68,W
14C6:  BSF    03.5
14C7:  BSF    03.6
14C8:  MOVWF  39
14C9:  BCF    03.5
14CA:  BCF    03.6
14CB:  MOVF   67,W
14CC:  BSF    03.5
14CD:  BSF    03.6
14CE:  MOVWF  38
14CF:  CLRF   3F
14D0:  CLRF   3E
14D1:  CLRF   3D
14D2:  MOVLW  64
14D3:  MOVWF  3C
14D4:  BCF    0A.4
14D5:  BCF    03.5
14D6:  BCF    03.6
14D7:  CALL   452
14D8:  BSF    0A.4
14D9:  MOVF   7A,W
14DA:  MOVWF  6A
14DB:  MOVF   79,W
14DC:  MOVWF  69
14DD:  MOVF   78,W
14DE:  MOVWF  68
14DF:  MOVF   77,W
14E0:  MOVWF  67
14E1:  BSF    03.6
....................    } 
....................  
....................    avel[0]=FP(1,Q); 
14E2:  BCF    03.6
14E3:  CLRF   6E
14E4:  CLRF   6D
14E5:  MOVLW  01
14E6:  MOVWF  6C
14E7:  CLRF   6B
....................    avel[1]=FP(-1,Q); 
14E8:  MOVLW  FF
14E9:  MOVWF  72
14EA:  MOVWF  71
14EB:  MOVWF  70
14EC:  CLRF   6F
....................    velocidad(); 
14ED:  BCF    0A.4
14EE:  BSF    0A.3
14EF:  CALL   59F
14F0:  BSF    0A.4
14F1:  BCF    0A.3
.................... } 
....................  
....................  
.................... //Control de Posicion con ingreso de referencia por teclado 
.................... void ContPos(void) 
.................... {    
....................    if((param==0)|(param==2))       //en caso se mantenga el controlador diseado 
*
1247:  MOVF   7C,F
1248:  BTFSC  03.2
1249:  GOTO   24C
124A:  MOVLW  00
124B:  GOTO   24D
124C:  MOVLW  01
124D:  BCF    03.5
124E:  BSF    03.6
124F:  MOVWF  28
1250:  MOVF   7C,W
1251:  SUBLW  02
1252:  BTFSC  03.2
1253:  GOTO   256
1254:  MOVLW  00
1255:  GOTO   257
1256:  MOVLW  01
1257:  IORWF  28,W
1258:  BTFSC  03.2
1259:  GOTO   263
....................       bpos[0]=B0_pos; 
125A:  BSF    03.5
125B:  BCF    03.6
125C:  CLRF   3F
125D:  CLRF   3E
125E:  CLRF   3D
125F:  MOVLW  47
1260:  MOVWF  3C
1261:  BCF    03.5
1262:  BSF    03.6
....................  
....................    if(param==1)               //cambio  del controlador 
1263:  DECFSZ 7C,W
1264:  GOTO   2B3
....................       {  bpos[0]=FP(b0,Q); 
1265:  BCF    03.6
1266:  MOVF   5E,W
1267:  BSF    03.5
1268:  BSF    03.6
1269:  MOVWF  38
126A:  BCF    03.5
126B:  BCF    03.6
126C:  MOVF   5D,W
126D:  BSF    03.5
126E:  BSF    03.6
126F:  MOVWF  37
1270:  BCF    03.5
1271:  BCF    03.6
1272:  MOVF   5C,W
1273:  BSF    03.5
1274:  BSF    03.6
1275:  MOVWF  36
1276:  BCF    03.5
1277:  BCF    03.6
1278:  MOVF   5B,W
1279:  BSF    03.5
127A:  BSF    03.6
127B:  MOVWF  35
127C:  CLRF   3C
127D:  CLRF   3B
127E:  MOVLW  01
127F:  MOVWF  3A
1280:  CLRF   39
1281:  BCF    0A.4
1282:  BCF    03.5
1283:  BCF    03.6
1284:  CALL   424
1285:  BSF    0A.4
1286:  MOVF   7A,W
1287:  BSF    03.5
1288:  MOVWF  3F
1289:  MOVF   79,W
128A:  MOVWF  3E
128B:  MOVF   78,W
128C:  MOVWF  3D
128D:  MOVF   77,W
128E:  MOVWF  3C
....................          bpos[0]=bpos[0]/RES; 
128F:  MOVF   3F,W
1290:  BSF    03.6
1291:  MOVWF  3B
1292:  BCF    03.6
1293:  MOVF   3E,W
1294:  BSF    03.6
1295:  MOVWF  3A
1296:  BCF    03.6
1297:  MOVF   3D,W
1298:  BSF    03.6
1299:  MOVWF  39
129A:  BCF    03.6
129B:  MOVF   3C,W
129C:  BSF    03.6
129D:  MOVWF  38
129E:  CLRF   3F
129F:  CLRF   3E
12A0:  CLRF   3D
12A1:  MOVLW  64
12A2:  MOVWF  3C
12A3:  BCF    0A.4
12A4:  BCF    03.5
12A5:  BCF    03.6
12A6:  CALL   452
12A7:  BSF    0A.4
12A8:  MOVF   7A,W
12A9:  BSF    03.5
12AA:  MOVWF  3F
12AB:  MOVF   79,W
12AC:  MOVWF  3E
12AD:  MOVF   78,W
12AE:  MOVWF  3D
12AF:  MOVF   77,W
12B0:  MOVWF  3C
12B1:  BCF    03.5
12B2:  BSF    03.6
....................       } 
....................    bpos[1]=FP(0,Q); 
12B3:  BSF    03.5
12B4:  BCF    03.6
12B5:  CLRF   43
12B6:  CLRF   42
12B7:  CLRF   41
12B8:  CLRF   40
....................    apos[0]=FP(0,Q); 
12B9:  CLRF   47
12BA:  CLRF   46
12BB:  CLRF   45
12BC:  CLRF   44
....................    posicion(); 
12BD:  BCF    0A.4
12BE:  BSF    0A.3
12BF:  BCF    03.5
12C0:  CALL   186
12C1:  BSF    0A.4
12C2:  BCF    0A.3
.................... } 
....................  
....................  
.................... //Referencia de Velocidad 
.................... Void RefVel() 
.................... { 
....................    set_adc_channel(1); 
*
1000:  MOVLW  08
1001:  MOVWF  78
1002:  MOVF   1F,W
1003:  ANDLW  C7
1004:  IORWF  78,W
1005:  MOVWF  1F
....................    delay_us(ESPERA);  
1006:  MOVLW  0D
1007:  MOVWF  77
1008:  DECFSZ 77,F
1009:  GOTO   008
....................    refevel=READ_ADC(); 
100A:  BSF    1F.2
100B:  BTFSC  1F.2
100C:  GOTO   00B
100D:  MOVF   1E,W
100E:  MOVWF  7A
100F:  BSF    03.5
1010:  MOVF   7A,W
1011:  MOVWF  78
1012:  CLRF   79
1013:  CLRF   7A
1014:  MOVF   7A,W
1015:  MOVWF  2B
1016:  MOVF   79,W
1017:  MOVWF  2A
1018:  MOVF   78,W
1019:  MOVWF  29
101A:  MOVF   1E,W
101B:  MOVWF  28
....................    delay_us(ESPERA); 
101C:  MOVLW  0D
101D:  MOVWF  77
101E:  DECFSZ 77,F
101F:  GOTO   01E
....................    velrefrpm=lineal_FP(FP(refevel,Q),(g)FP(31,Q),(g)FP(997,Q),(g)FP(-60,Q),(g)FP(60,Q));  
1020:  MOVF   2B,W
1021:  BSF    03.6
1022:  MOVWF  38
1023:  BCF    03.6
1024:  MOVF   2A,W
1025:  BSF    03.6
1026:  MOVWF  37
1027:  BCF    03.6
1028:  MOVF   29,W
1029:  BSF    03.6
102A:  MOVWF  36
102B:  BCF    03.6
102C:  MOVF   28,W
102D:  BSF    03.6
102E:  MOVWF  35
102F:  CLRF   3C
1030:  CLRF   3B
1031:  MOVLW  01
1032:  MOVWF  3A
1033:  CLRF   39
1034:  BCF    0A.4
1035:  BCF    03.5
1036:  BCF    03.6
1037:  CALL   424
1038:  BSF    0A.4
1039:  MOVF   7A,W
103A:  BSF    03.6
103B:  MOVWF  2C
103C:  MOVF   79,W
103D:  MOVWF  2B
103E:  MOVF   78,W
103F:  MOVWF  2A
1040:  MOVF   77,W
1041:  MOVWF  29
1042:  MOVF   2C,W
1043:  MOVWF  38
1044:  MOVF   2B,W
1045:  MOVWF  37
1046:  MOVF   2A,W
1047:  MOVWF  36
1048:  MOVF   29,W
1049:  MOVWF  35
104A:  CLRF   3C
104B:  CLRF   3B
104C:  MOVLW  1F
104D:  MOVWF  3A
104E:  CLRF   39
104F:  CLRF   40
1050:  MOVLW  03
1051:  MOVWF  3F
1052:  MOVLW  E5
1053:  MOVWF  3E
1054:  CLRF   3D
1055:  MOVLW  FF
1056:  MOVWF  44
1057:  MOVWF  43
1058:  MOVLW  C4
1059:  MOVWF  42
105A:  CLRF   41
105B:  CLRF   48
105C:  CLRF   47
105D:  MOVLW  3C
105E:  MOVWF  46
105F:  CLRF   45
1060:  BCF    0A.4
1061:  BCF    03.6
1062:  CALL   4C3
1063:  BSF    0A.4
1064:  MOVF   7A,W
1065:  MOVWF  76
1066:  MOVF   79,W
1067:  MOVWF  75
1068:  MOVF   78,W
1069:  MOVWF  74
106A:  MOVF   77,W
106B:  MOVWF  73
....................    numero=velrefrpm; 
106C:  MOVF   76,W
106D:  BSF    03.5
106E:  MOVWF  67
106F:  MOVF   75,W
1070:  MOVWF  66
1071:  MOVF   74,W
1072:  MOVWF  65
1073:  MOVF   73,W
1074:  MOVWF  64
....................    velocidad(); 
1075:  BCF    0A.4
1076:  BSF    0A.3
1077:  BCF    03.5
1078:  CALL   59F
1079:  BSF    0A.4
107A:  BCF    0A.3
.................... } 
107B:  RETLW  00
....................  
....................  
.................... //Referencia de Posicion 
.................... void RefPos(void) 
.................... { 
....................    set_adc_channel(1); 
*
0BA1:  MOVLW  08
0BA2:  MOVWF  78
0BA3:  MOVF   1F,W
0BA4:  ANDLW  C7
0BA5:  IORWF  78,W
0BA6:  MOVWF  1F
....................    delay_us(ESPERA);  
0BA7:  MOVLW  0D
0BA8:  MOVWF  77
0BA9:  DECFSZ 77,F
0BAA:  GOTO   3A9
....................    refepos=Read_ADC(); 
0BAB:  BSF    1F.2
0BAC:  BTFSC  1F.2
0BAD:  GOTO   3AC
0BAE:  MOVF   1E,W
0BAF:  MOVWF  7A
0BB0:  BSF    03.5
0BB1:  MOVF   7A,W
0BB2:  MOVWF  78
0BB3:  CLRF   79
0BB4:  CLRF   7A
0BB5:  MOVF   7A,W
0BB6:  MOVWF  57
0BB7:  MOVF   79,W
0BB8:  MOVWF  56
0BB9:  MOVF   78,W
0BBA:  MOVWF  55
0BBB:  MOVF   1E,W
0BBC:  MOVWF  54
....................    delay_us(ESPERA); 
0BBD:  MOVLW  0D
0BBE:  MOVWF  77
0BBF:  DECFSZ 77,F
0BC0:  GOTO   3BF
....................    ///printf("\n\r RefPOS    %ld       \r",refepos); 
....................    posrefgr=lineal_FP(FP(refepos,Q),(g)FP(31,Q),(g)FP(997,Q),(g)FP(150,Q),(g)FP(-150,Q));  
0BC1:  MOVF   57,W
0BC2:  BSF    03.6
0BC3:  MOVWF  38
0BC4:  BCF    03.6
0BC5:  MOVF   56,W
0BC6:  BSF    03.6
0BC7:  MOVWF  37
0BC8:  BCF    03.6
0BC9:  MOVF   55,W
0BCA:  BSF    03.6
0BCB:  MOVWF  36
0BCC:  BCF    03.6
0BCD:  MOVF   54,W
0BCE:  BSF    03.6
0BCF:  MOVWF  35
0BD0:  CLRF   3C
0BD1:  CLRF   3B
0BD2:  MOVLW  01
0BD3:  MOVWF  3A
0BD4:  CLRF   39
0BD5:  BCF    0A.3
0BD6:  BCF    03.5
0BD7:  BCF    03.6
0BD8:  CALL   424
0BD9:  BSF    0A.3
0BDA:  MOVF   7A,W
0BDB:  BSF    03.6
0BDC:  MOVWF  2C
0BDD:  MOVF   79,W
0BDE:  MOVWF  2B
0BDF:  MOVF   78,W
0BE0:  MOVWF  2A
0BE1:  MOVF   77,W
0BE2:  MOVWF  29
0BE3:  MOVF   2C,W
0BE4:  MOVWF  38
0BE5:  MOVF   2B,W
0BE6:  MOVWF  37
0BE7:  MOVF   2A,W
0BE8:  MOVWF  36
0BE9:  MOVF   29,W
0BEA:  MOVWF  35
0BEB:  CLRF   3C
0BEC:  CLRF   3B
0BED:  MOVLW  1F
0BEE:  MOVWF  3A
0BEF:  CLRF   39
0BF0:  CLRF   40
0BF1:  MOVLW  03
0BF2:  MOVWF  3F
0BF3:  MOVLW  E5
0BF4:  MOVWF  3E
0BF5:  CLRF   3D
0BF6:  CLRF   44
0BF7:  CLRF   43
0BF8:  MOVLW  96
0BF9:  MOVWF  42
0BFA:  CLRF   41
0BFB:  MOVLW  FF
0BFC:  MOVWF  48
0BFD:  MOVWF  47
0BFE:  MOVLW  6A
0BFF:  MOVWF  46
0C00:  CLRF   45
0C01:  BCF    0A.3
0C02:  BCF    03.6
0C03:  CALL   4C3
0C04:  BSF    0A.3
0C05:  MOVF   7A,W
0C06:  BSF    03.5
0C07:  MOVWF  4B
0C08:  MOVF   79,W
0C09:  MOVWF  4A
0C0A:  MOVF   78,W
0C0B:  MOVWF  49
0C0C:  MOVF   77,W
0C0D:  MOVWF  48
....................    numero=-posrefgr; 
0C0E:  COMF   48,W
0C0F:  MOVWF  64
0C10:  COMF   49,W
0C11:  MOVWF  65
0C12:  COMF   4A,W
0C13:  MOVWF  66
0C14:  COMF   4B,W
0C15:  MOVWF  67
0C16:  INCF   64,F
0C17:  BTFSC  03.2
0C18:  INCF   65,F
0C19:  BTFSC  03.2
0C1A:  INCF   66,F
0C1B:  BTFSC  03.2
0C1C:  INCF   67,F
....................    posicion(); 
0C1D:  BCF    03.5
0C1E:  CALL   186
.................... } 
0C1F:  RETLW  00
....................  
....................  
.................... // IRQ Timer0: refresco de los displays de 7 segmentos (un digito por IRQ) 
.................... // ===========      // Adicional "rutina de silencio" 
.................... #int_TIMER0 
.................... void TIMER0_isr(void) 
.................... {   switch(display) 
....................    {    
*
03EB:  BSF    03.5
03EC:  MOVF   69,W
03ED:  BCF    03.5
03EE:  BTFSC  03.2
03EF:  GOTO   3F7
03F0:  XORLW  01
03F1:  BTFSC  03.2
03F2:  GOTO   3FF
03F3:  XORLW  03
03F4:  BTFSC  03.2
03F5:  GOTO   407
03F6:  GOTO   411
....................      case 0: 
....................          PORTD=u;            // Unidades    
03F7:  MOVF   7D,W
03F8:  MOVWF  08
....................          cen=1;             // apaga el display de centenas 
03F9:  BSF    09.2
....................          uni=0;             // enciende el display de unidades 
03FA:  BCF    09.0
....................          display++;         // incrementa la cuenta para que la prxima  
03FB:  BSF    03.5
03FC:  INCF   69,F
....................          break;             // IRQ entre en case siguiente 
03FD:  BCF    03.5
03FE:  GOTO   411
....................       case 1: 
....................          PORTD=d;            // Decenas    
03FF:  MOVF   7E,W
0400:  MOVWF  08
....................          uni=1; 
0401:  BSF    09.0
....................          dec=0; 
0402:  BCF    09.1
....................          display++;    
0403:  BSF    03.5
0404:  INCF   69,F
....................          break; 
0405:  BCF    03.5
0406:  GOTO   411
....................       case 2: 
....................          PORTD=c;            // Centenas    
0407:  BSF    03.5
0408:  MOVF   68,W
0409:  BCF    03.5
040A:  MOVWF  08
....................          dec=1; 
040B:  BSF    09.1
....................          cen=0; 
040C:  BCF    09.2
....................          display=0;         // resetea la cuenta    
040D:  BSF    03.5
040E:  CLRF   69
....................          break; 
040F:  BCF    03.5
0410:  GOTO   411
....................    } 
....................    if (!pulsador)         // rutina de silencio (Aleluyaaa) 
0411:  BTFSC  06.0
0412:  GOTO   420
....................    { 
....................     noise=~noise; 
0413:  COMF   2F,F
....................     if (noise) 
0414:  MOVF   2F,F
0415:  BTFSC  03.2
0416:  GOTO   41C
....................       {    
....................          TRISC= 0x84;      // apaga la salida PWM por hardware 
0417:  MOVLW  84
0418:  BSF    03.5
0419:  MOVWF  07
....................          delay_us(ESPERA2); 
....................       } 
....................       else 
041A:  GOTO   41F
041B:  BCF    03.5
....................       {  TRISC= 0x80;      // activa la salida PWM por hardware 
041C:  MOVLW  80
041D:  BSF    03.5
041E:  MOVWF  07
041F:  BCF    03.5
....................          delay_us(ESPERA2); 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // IRQ RDA: Dato recibido en USART 
.................... // ======== 
0420:  BCF    0B.2
0421:  BCF    0A.3
0422:  BCF    0A.4
0423:  GOTO   029
.................... #int_RDA 
.................... void RDA_isr(void) 
.................... { 
....................    int caracter; 
....................    output_bit(PIN_B5,1);      // destello LED LINK 
*
1116:  BSF    06.5
1117:  BSF    03.5
1118:  BCF    06.5
....................  
....................    if(kbhit()) 
1119:  BCF    03.5
111A:  BTFSS  0C.5
111B:  GOTO   6F4
....................     {                         
....................       caracter=getch(); 
111C:  BTFSS  0C.5
111D:  GOTO   11C
111E:  MOVF   1A,W
111F:  BSF    03.6
1120:  MOVWF  27
....................       switch (caracter)         // menu  
....................       { 
1121:  MOVF   27,W
1122:  XORLW  31
1123:  BCF    03.6
1124:  BTFSC  03.2
1125:  GOTO   139
1126:  XORLW  03
1127:  BTFSC  03.2
1128:  GOTO   1CB
1129:  XORLW  01
112A:  BTFSC  03.2
112B:  GOTO   2C4
112C:  XORLW  07
112D:  BTFSC  03.2
112E:  GOTO   3AB
112F:  XORLW  01
1130:  BTFSC  03.2
1131:  GOTO   4F3
1132:  XORLW  03
1133:  BTFSC  03.2
1134:  GOTO   56D
1135:  XORLW  01
1136:  BTFSC  03.2
1137:  GOTO   64C
1138:  GOTO   662
....................           case '1': 
....................             printf("\n\rCONTROL DE POSICION  -  POTENCIOMETRO\n\r"); 
1139:  BSF    03.6
113A:  CLRF   28
113B:  MOVF   28,W
113C:  BCF    0A.4
113D:  BCF    03.6
113E:  CALL   045
113F:  BSF    0A.4
1140:  BSF    03.6
1141:  INCF   28,F
1142:  MOVWF  77
1143:  BCF    03.6
1144:  BTFSS  0C.4
1145:  GOTO   144
1146:  MOVWF  19
1147:  MOVLW  29
1148:  BSF    03.6
1149:  SUBWF  28,W
114A:  BTFSS  03.2
114B:  GOTO   13B
....................             modo=4; 
114C:  MOVLW  04
114D:  BCF    03.6
114E:  MOVWF  30
....................          // Asigno el controlador POS 
....................             if((param==0)|(param==2))         //mantenemos el controlador disenado 
114F:  MOVF   7C,F
1150:  BTFSC  03.2
1151:  GOTO   154
1152:  MOVLW  00
1153:  GOTO   155
1154:  MOVLW  01
1155:  BSF    03.6
1156:  MOVWF  28
1157:  MOVF   7C,W
1158:  SUBLW  02
1159:  BTFSC  03.2
115A:  GOTO   15D
115B:  MOVLW  00
115C:  GOTO   15E
115D:  MOVLW  01
115E:  IORWF  28,W
115F:  BTFSC  03.2
1160:  GOTO   16A
....................                   bpos[0]=B0_pos;     
1161:  BSF    03.5
1162:  BCF    03.6
1163:  CLRF   3F
1164:  CLRF   3E
1165:  CLRF   3D
1166:  MOVLW  47
1167:  MOVWF  3C
1168:  BCF    03.5
1169:  BSF    03.6
....................                if(param==1)                  //cambio  del controlador 
116A:  DECFSZ 7C,W
116B:  GOTO   1BA
....................                   {  bpos[0]=FP(b0,Q); 
116C:  BCF    03.6
116D:  MOVF   5E,W
116E:  BSF    03.5
116F:  BSF    03.6
1170:  MOVWF  38
1171:  BCF    03.5
1172:  BCF    03.6
1173:  MOVF   5D,W
1174:  BSF    03.5
1175:  BSF    03.6
1176:  MOVWF  37
1177:  BCF    03.5
1178:  BCF    03.6
1179:  MOVF   5C,W
117A:  BSF    03.5
117B:  BSF    03.6
117C:  MOVWF  36
117D:  BCF    03.5
117E:  BCF    03.6
117F:  MOVF   5B,W
1180:  BSF    03.5
1181:  BSF    03.6
1182:  MOVWF  35
1183:  CLRF   3C
1184:  CLRF   3B
1185:  MOVLW  01
1186:  MOVWF  3A
1187:  CLRF   39
1188:  BCF    0A.4
1189:  BCF    03.5
118A:  BCF    03.6
118B:  CALL   424
118C:  BSF    0A.4
118D:  MOVF   7A,W
118E:  BSF    03.5
118F:  MOVWF  3F
1190:  MOVF   79,W
1191:  MOVWF  3E
1192:  MOVF   78,W
1193:  MOVWF  3D
1194:  MOVF   77,W
1195:  MOVWF  3C
....................                      bpos[0]=bpos[0]/RES; 
1196:  MOVF   3F,W
1197:  BSF    03.6
1198:  MOVWF  3B
1199:  BCF    03.6
119A:  MOVF   3E,W
119B:  BSF    03.6
119C:  MOVWF  3A
119D:  BCF    03.6
119E:  MOVF   3D,W
119F:  BSF    03.6
11A0:  MOVWF  39
11A1:  BCF    03.6
11A2:  MOVF   3C,W
11A3:  BSF    03.6
11A4:  MOVWF  38
11A5:  CLRF   3F
11A6:  CLRF   3E
11A7:  CLRF   3D
11A8:  MOVLW  64
11A9:  MOVWF  3C
11AA:  BCF    0A.4
11AB:  BCF    03.5
11AC:  BCF    03.6
11AD:  CALL   452
11AE:  BSF    0A.4
11AF:  MOVF   7A,W
11B0:  BSF    03.5
11B1:  MOVWF  3F
11B2:  MOVF   79,W
11B3:  MOVWF  3E
11B4:  MOVF   78,W
11B5:  MOVWF  3D
11B6:  MOVF   77,W
11B7:  MOVWF  3C
11B8:  BCF    03.5
11B9:  BSF    03.6
....................                      } 
....................                bpos[1]=FP(0,Q); 
11BA:  BSF    03.5
11BB:  BCF    03.6
11BC:  CLRF   43
11BD:  CLRF   42
11BE:  CLRF   41
11BF:  CLRF   40
....................                apos[0]=FP(0,Q); 
11C0:  CLRF   47
11C1:  CLRF   46
11C2:  CLRF   45
11C3:  CLRF   44
....................  
....................          RefPos(); 
11C4:  BCF    0A.4
11C5:  BSF    0A.3
11C6:  BCF    03.5
11C7:  CALL   3A1
11C8:  BSF    0A.4
11C9:  BCF    0A.3
....................             break; 
11CA:  GOTO   6F4
....................              
....................              
....................          case '2': 
....................             printf("\n\rCONTROL DE POSICION  -  TECLADO < Rango: 30* @ 330* >\n\r"); 
11CB:  BSF    03.6
11CC:  CLRF   28
11CD:  MOVF   28,W
11CE:  BCF    0A.4
11CF:  BCF    03.6
11D0:  CALL   073
11D1:  BSF    0A.4
11D2:  BSF    03.6
11D3:  INCF   28,F
11D4:  MOVWF  77
11D5:  BCF    03.6
11D6:  BTFSS  0C.4
11D7:  GOTO   1D6
11D8:  MOVWF  19
11D9:  MOVLW  39
11DA:  BSF    03.6
11DB:  SUBWF  28,W
11DC:  BTFSS  03.2
11DD:  GOTO   1CD
....................             modo=2; 
11DE:  MOVLW  02
11DF:  BCF    03.6
11E0:  MOVWF  30
....................             gets(texto);                           // Espera una palabra de hasta 10 caracteres 
11E1:  MOVLW  31
11E2:  MOVWF  04
11E3:  BCF    03.7
11E4:  DECF   04,F
11E5:  INCF   04,F
11E6:  BTFSS  0C.5
11E7:  GOTO   1E6
11E8:  MOVF   1A,W
11E9:  MOVWF  00
11EA:  MOVLW  0D
11EB:  SUBWF  00,W
11EC:  BTFSS  03.2
11ED:  GOTO   1E5
11EE:  CLRF   00
....................             printf("Referencia POS: %s ",texto);   // Regresa el valor para corroborar que lo tomo bien   
11EF:  BSF    03.6
11F0:  CLRF   28
11F1:  MOVF   28,W
11F2:  BCF    0A.4
11F3:  BCF    03.6
11F4:  CALL   0B1
11F5:  BSF    0A.4
11F6:  BSF    03.6
11F7:  INCF   28,F
11F8:  MOVWF  77
11F9:  BCF    03.6
11FA:  BTFSS  0C.4
11FB:  GOTO   1FA
11FC:  MOVWF  19
11FD:  MOVLW  10
11FE:  BSF    03.6
11FF:  SUBWF  28,W
1200:  BTFSS  03.2
1201:  GOTO   1F1
1202:  MOVLW  31
1203:  MOVWF  04
1204:  BCF    03.7
1205:  MOVLW  00
1206:  IORWF  00,W
1207:  BTFSC  03.2
1208:  GOTO   211
1209:  MOVF   00,W
120A:  BCF    03.6
120B:  BTFSS  0C.4
120C:  GOTO   20B
120D:  MOVWF  19
120E:  INCF   04,F
120F:  BSF    03.6
1210:  GOTO   205
1211:  MOVLW  20
1212:  BCF    03.6
1213:  BTFSS  0C.4
1214:  GOTO   213
1215:  MOVWF  19
....................             valor=atoi32(texto);                   // Convierte los caracteres en un numero 
1216:  BSF    03.6
1217:  CLRF   29
1218:  MOVLW  31
1219:  MOVWF  28
121A:  BCF    0A.4
121B:  BSF    0A.3
121C:  BCF    03.6
121D:  CALL   420
121E:  BSF    0A.4
121F:  BCF    0A.3
1220:  MOVF   7A,W
1221:  MOVWF  56
1222:  MOVF   79,W
1223:  MOVWF  55
1224:  MOVF   78,W
1225:  MOVWF  54
1226:  MOVF   77,W
1227:  MOVWF  53
....................             numero=valor; 
1228:  MOVF   56,W
1229:  BSF    03.5
122A:  MOVWF  67
122B:  BCF    03.5
122C:  MOVF   55,W
122D:  BSF    03.5
122E:  MOVWF  66
122F:  BCF    03.5
1230:  MOVF   54,W
1231:  BSF    03.5
1232:  MOVWF  65
1233:  BCF    03.5
1234:  MOVF   53,W
1235:  BSF    03.5
1236:  MOVWF  64
....................             posrefgr=valor; 
1237:  BCF    03.5
1238:  MOVF   56,W
1239:  BSF    03.5
123A:  MOVWF  4B
123B:  BCF    03.5
123C:  MOVF   55,W
123D:  BSF    03.5
123E:  MOVWF  4A
123F:  BCF    03.5
1240:  MOVF   54,W
1241:  BSF    03.5
1242:  MOVWF  49
1243:  BCF    03.5
1244:  MOVF   53,W
1245:  BSF    03.5
1246:  MOVWF  48
....................          ContPos(); 
....................             break; 
*
12C3:  GOTO   6F4
....................              
....................              
....................          case '3': 
....................             printf("\n\rCONTROL DE VELOCIDAD  -  POTENCIOMETRO\n\r"); 
12C4:  BSF    03.6
12C5:  CLRF   28
12C6:  MOVF   28,W
12C7:  BCF    0A.4
12C8:  BCF    03.6
12C9:  CALL   0C9
12CA:  BSF    0A.4
12CB:  BSF    03.6
12CC:  INCF   28,F
12CD:  MOVWF  77
12CE:  BCF    03.6
12CF:  BTFSS  0C.4
12D0:  GOTO   2CF
12D1:  MOVWF  19
12D2:  MOVLW  2A
12D3:  BSF    03.6
12D4:  SUBWF  28,W
12D5:  BTFSS  03.2
12D6:  GOTO   2C6
....................             modo=3; 
12D7:  MOVLW  03
12D8:  BCF    03.6
12D9:  MOVWF  30
....................          // Asigno el controlador VEL 
....................           if((param==0)|(param==1))          // mantenemos el controlador disenado 
12DA:  MOVF   7C,F
12DB:  BTFSC  03.2
12DC:  GOTO   2DF
12DD:  MOVLW  00
12DE:  GOTO   2E0
12DF:  MOVLW  01
12E0:  BSF    03.6
12E1:  MOVWF  28
12E2:  DECFSZ 7C,W
12E3:  GOTO   2E5
12E4:  GOTO   2E7
12E5:  MOVLW  00
12E6:  GOTO   2E8
12E7:  MOVLW  01
12E8:  IORWF  28,W
12E9:  BTFSC  03.2
12EA:  GOTO   2F8
....................             {  bvel[0]=B0_vel;   
12EB:  BCF    03.6
12EC:  CLRF   66
12ED:  CLRF   65
12EE:  CLRF   64
12EF:  MOVLW  5C
12F0:  MOVWF  63
....................                bvel[1]=B1_vel;  
12F1:  MOVLW  FF
12F2:  MOVWF  6A
12F3:  MOVWF  69
12F4:  MOVWF  68
12F5:  MOVLW  AC
12F6:  MOVWF  67
12F7:  BSF    03.6
....................             } 
....................           if(param==2)                   // cambio  del controlador 
12F8:  MOVF   7C,W
12F9:  SUBLW  02
12FA:  BTFSS  03.2
12FB:  GOTO   39E
....................             {  bvel[0]=FP(b0,Q); 
12FC:  BCF    03.6
12FD:  MOVF   5E,W
12FE:  BSF    03.5
12FF:  BSF    03.6
1300:  MOVWF  38
1301:  BCF    03.5
1302:  BCF    03.6
1303:  MOVF   5D,W
1304:  BSF    03.5
1305:  BSF    03.6
1306:  MOVWF  37
1307:  BCF    03.5
1308:  BCF    03.6
1309:  MOVF   5C,W
130A:  BSF    03.5
130B:  BSF    03.6
130C:  MOVWF  36
130D:  BCF    03.5
130E:  BCF    03.6
130F:  MOVF   5B,W
1310:  BSF    03.5
1311:  BSF    03.6
1312:  MOVWF  35
1313:  CLRF   3C
1314:  CLRF   3B
1315:  MOVLW  01
1316:  MOVWF  3A
1317:  CLRF   39
1318:  BCF    0A.4
1319:  BCF    03.5
131A:  BCF    03.6
131B:  CALL   424
131C:  BSF    0A.4
131D:  MOVF   7A,W
131E:  MOVWF  66
131F:  MOVF   79,W
1320:  MOVWF  65
1321:  MOVF   78,W
1322:  MOVWF  64
1323:  MOVF   77,W
1324:  MOVWF  63
....................                 bvel[0]=bvel[0]/RES; 
1325:  MOVF   66,W
1326:  BSF    03.5
1327:  BSF    03.6
1328:  MOVWF  3B
1329:  BCF    03.5
132A:  BCF    03.6
132B:  MOVF   65,W
132C:  BSF    03.5
132D:  BSF    03.6
132E:  MOVWF  3A
132F:  BCF    03.5
1330:  BCF    03.6
1331:  MOVF   64,W
1332:  BSF    03.5
1333:  BSF    03.6
1334:  MOVWF  39
1335:  BCF    03.5
1336:  BCF    03.6
1337:  MOVF   63,W
1338:  BSF    03.5
1339:  BSF    03.6
133A:  MOVWF  38
133B:  CLRF   3F
133C:  CLRF   3E
133D:  CLRF   3D
133E:  MOVLW  64
133F:  MOVWF  3C
1340:  BCF    0A.4
1341:  BCF    03.5
1342:  BCF    03.6
1343:  CALL   452
1344:  BSF    0A.4
1345:  MOVF   7A,W
1346:  MOVWF  66
1347:  MOVF   79,W
1348:  MOVWF  65
1349:  MOVF   78,W
134A:  MOVWF  64
134B:  MOVF   77,W
134C:  MOVWF  63
....................                bvel[1]=FP(b1,Q); 
134D:  MOVF   62,W
134E:  BSF    03.5
134F:  BSF    03.6
1350:  MOVWF  38
1351:  BCF    03.5
1352:  BCF    03.6
1353:  MOVF   61,W
1354:  BSF    03.5
1355:  BSF    03.6
1356:  MOVWF  37
1357:  BCF    03.5
1358:  BCF    03.6
1359:  MOVF   60,W
135A:  BSF    03.5
135B:  BSF    03.6
135C:  MOVWF  36
135D:  BCF    03.5
135E:  BCF    03.6
135F:  MOVF   5F,W
1360:  BSF    03.5
1361:  BSF    03.6
1362:  MOVWF  35
1363:  CLRF   3C
1364:  CLRF   3B
1365:  MOVLW  01
1366:  MOVWF  3A
1367:  CLRF   39
1368:  BCF    0A.4
1369:  BCF    03.5
136A:  BCF    03.6
136B:  CALL   424
136C:  BSF    0A.4
136D:  MOVF   7A,W
136E:  MOVWF  6A
136F:  MOVF   79,W
1370:  MOVWF  69
1371:  MOVF   78,W
1372:  MOVWF  68
1373:  MOVF   77,W
1374:  MOVWF  67
....................                bvel[1]=bvel[1]/RES; 
1375:  MOVF   6A,W
1376:  BSF    03.5
1377:  BSF    03.6
1378:  MOVWF  3B
1379:  BCF    03.5
137A:  BCF    03.6
137B:  MOVF   69,W
137C:  BSF    03.5
137D:  BSF    03.6
137E:  MOVWF  3A
137F:  BCF    03.5
1380:  BCF    03.6
1381:  MOVF   68,W
1382:  BSF    03.5
1383:  BSF    03.6
1384:  MOVWF  39
1385:  BCF    03.5
1386:  BCF    03.6
1387:  MOVF   67,W
1388:  BSF    03.5
1389:  BSF    03.6
138A:  MOVWF  38
138B:  CLRF   3F
138C:  CLRF   3E
138D:  CLRF   3D
138E:  MOVLW  64
138F:  MOVWF  3C
1390:  BCF    0A.4
1391:  BCF    03.5
1392:  BCF    03.6
1393:  CALL   452
1394:  BSF    0A.4
1395:  MOVF   7A,W
1396:  MOVWF  6A
1397:  MOVF   79,W
1398:  MOVWF  69
1399:  MOVF   78,W
139A:  MOVWF  68
139B:  MOVF   77,W
139C:  MOVWF  67
139D:  BSF    03.6
....................             } 
....................            avel[0]=FP(1,Q); 
139E:  BCF    03.6
139F:  CLRF   6E
13A0:  CLRF   6D
13A1:  MOVLW  01
13A2:  MOVWF  6C
13A3:  CLRF   6B
....................              avel[1]=FP(-1,Q); 
13A4:  MOVLW  FF
13A5:  MOVWF  72
13A6:  MOVWF  71
13A7:  MOVWF  70
13A8:  CLRF   6F
....................  
....................          RefVel(); 
13A9:  CALL   000
....................             break; 
13AA:  GOTO   6F4
....................              
....................     
....................          case '4': 
....................             printf("\n\rCONTROL DE VELOCIDAD  -  TECLADO < Rango: (-64rpm @ 64rpm) x 32>\n\r"); 
13AB:  BSF    03.6
13AC:  CLRF   28
13AD:  MOVF   28,W
13AE:  BCF    0A.4
13AF:  BCF    03.6
13B0:  CALL   0F8
13B1:  BSF    0A.4
13B2:  BSF    03.6
13B3:  INCF   28,F
13B4:  MOVWF  77
13B5:  BCF    03.6
13B6:  BTFSS  0C.4
13B7:  GOTO   3B6
13B8:  MOVWF  19
13B9:  MOVLW  44
13BA:  BSF    03.6
13BB:  SUBWF  28,W
13BC:  BTFSS  03.2
13BD:  GOTO   3AD
....................             modo=1; 
13BE:  MOVLW  01
13BF:  BCF    03.6
13C0:  MOVWF  30
....................             gets(texto);                           // Espera una palabra de hasta 10 caracteres 
13C1:  MOVLW  31
13C2:  MOVWF  04
13C3:  BCF    03.7
13C4:  DECF   04,F
13C5:  INCF   04,F
13C6:  BTFSS  0C.5
13C7:  GOTO   3C6
13C8:  MOVF   1A,W
13C9:  MOVWF  00
13CA:  MOVLW  0D
13CB:  SUBWF  00,W
13CC:  BTFSS  03.2
13CD:  GOTO   3C5
13CE:  CLRF   00
....................             printf("Referencia VEL: %s ",texto);   // Regresa el valor para corroborar que lo tomo bien 
13CF:  BSF    03.6
13D0:  CLRF   28
13D1:  MOVF   28,W
13D2:  BCF    0A.4
13D3:  BCF    03.6
13D4:  CALL   147
13D5:  BSF    0A.4
13D6:  BSF    03.6
13D7:  INCF   28,F
13D8:  MOVWF  77
13D9:  BCF    03.6
13DA:  BTFSS  0C.4
13DB:  GOTO   3DA
13DC:  MOVWF  19
13DD:  MOVLW  10
13DE:  BSF    03.6
13DF:  SUBWF  28,W
13E0:  BTFSS  03.2
13E1:  GOTO   3D1
13E2:  MOVLW  31
13E3:  MOVWF  04
13E4:  BCF    03.7
13E5:  MOVLW  00
13E6:  IORWF  00,W
13E7:  BTFSC  03.2
13E8:  GOTO   3F1
13E9:  MOVF   00,W
13EA:  BCF    03.6
13EB:  BTFSS  0C.4
13EC:  GOTO   3EB
13ED:  MOVWF  19
13EE:  INCF   04,F
13EF:  BSF    03.6
13F0:  GOTO   3E5
13F1:  MOVLW  20
13F2:  BCF    03.6
13F3:  BTFSS  0C.4
13F4:  GOTO   3F3
13F5:  MOVWF  19
....................             valor=atoi32(texto);                   // Convierte los caracteres en un numero 
13F6:  BSF    03.6
13F7:  CLRF   29
13F8:  MOVLW  31
13F9:  MOVWF  28
13FA:  BCF    0A.4
13FB:  BSF    0A.3
13FC:  BCF    03.6
13FD:  CALL   420
13FE:  BSF    0A.4
13FF:  BCF    0A.3
1400:  MOVF   7A,W
1401:  MOVWF  56
1402:  MOVF   79,W
1403:  MOVWF  55
1404:  MOVF   78,W
1405:  MOVWF  54
1406:  MOVF   77,W
1407:  MOVWF  53
....................             numero=valor; 
1408:  MOVF   56,W
1409:  BSF    03.5
140A:  MOVWF  67
140B:  BCF    03.5
140C:  MOVF   55,W
140D:  BSF    03.5
140E:  MOVWF  66
140F:  BCF    03.5
1410:  MOVF   54,W
1411:  BSF    03.5
1412:  MOVWF  65
1413:  BCF    03.5
1414:  MOVF   53,W
1415:  BSF    03.5
1416:  MOVWF  64
....................             velrefrpm=valor; 
1417:  BCF    03.5
1418:  MOVF   56,W
1419:  MOVWF  76
141A:  MOVF   55,W
141B:  MOVWF  75
141C:  MOVF   54,W
141D:  MOVWF  74
141E:  MOVF   53,W
141F:  MOVWF  73
....................          ContVel(); 
....................             break; 
*
14F2:  GOTO   6F4
....................              
....................              
....................          case '5': 
....................             param=1; 
14F3:  MOVLW  01
14F4:  MOVWF  7C
....................             printf("\n\r\nParametros de posicion afectados x 100 para tener mas resolucion:\n\r"); 
14F5:  BSF    03.6
14F6:  CLRF   28
14F7:  MOVF   28,W
14F8:  BCF    0A.4
14F9:  BCF    03.6
14FA:  CALL   15F
14FB:  BSF    0A.4
14FC:  BSF    03.6
14FD:  INCF   28,F
14FE:  MOVWF  77
14FF:  BCF    03.6
1500:  BTFSS  0C.4
1501:  GOTO   500
1502:  MOVWF  19
1503:  MOVLW  46
1504:  BSF    03.6
1505:  SUBWF  28,W
1506:  BTFSS  03.2
1507:  GOTO   4F7
....................             printf("\n\r   > Introduzca B0\n\r"); 
1508:  CLRF   28
1509:  MOVF   28,W
150A:  BCF    0A.4
150B:  BCF    03.6
150C:  CALL   1AA
150D:  BSF    0A.4
150E:  BSF    03.6
150F:  INCF   28,F
1510:  MOVWF  77
1511:  BCF    03.6
1512:  BTFSS  0C.4
1513:  GOTO   512
1514:  MOVWF  19
1515:  MOVLW  16
1516:  BSF    03.6
1517:  SUBWF  28,W
1518:  BTFSS  03.2
1519:  GOTO   509
....................             gets(texto);  
151A:  MOVLW  31
151B:  MOVWF  04
151C:  BCF    03.7
151D:  DECF   04,F
151E:  INCF   04,F
151F:  BCF    03.6
1520:  BTFSS  0C.5
1521:  GOTO   520
1522:  MOVF   1A,W
1523:  MOVWF  00
1524:  MOVLW  0D
1525:  SUBWF  00,W
1526:  BTFSC  03.2
1527:  GOTO   52A
1528:  BSF    03.6
1529:  GOTO   51E
152A:  CLRF   00
....................             b0=atoi32(texto); 
152B:  BSF    03.6
152C:  CLRF   29
152D:  MOVLW  31
152E:  MOVWF  28
152F:  BCF    0A.4
1530:  BSF    0A.3
1531:  BCF    03.6
1532:  CALL   420
1533:  BSF    0A.4
1534:  BCF    0A.3
1535:  MOVF   7A,W
1536:  MOVWF  5E
1537:  MOVF   79,W
1538:  MOVWF  5D
1539:  MOVF   78,W
153A:  MOVWF  5C
153B:  MOVF   77,W
153C:  MOVWF  5B
....................             printf("\n\r   Nuevo valor de B0 x 100 = %ld \r",b0);  
153D:  BSF    03.6
153E:  CLRF   28
153F:  MOVF   28,W
1540:  BCF    0A.4
1541:  BCF    03.6
1542:  CALL   1C5
1543:  BSF    0A.4
1544:  BSF    03.6
1545:  INCF   28,F
1546:  MOVWF  77
1547:  BCF    03.6
1548:  BTFSS  0C.4
1549:  GOTO   548
154A:  MOVWF  19
154B:  MOVLW  1F
154C:  BSF    03.6
154D:  SUBWF  28,W
154E:  BTFSS  03.2
154F:  GOTO   53F
1550:  MOVLW  41
1551:  MOVWF  04
1552:  BCF    03.6
1553:  MOVF   5E,W
1554:  BSF    03.6
1555:  MOVWF  2C
1556:  BCF    03.6
1557:  MOVF   5D,W
1558:  BSF    03.6
1559:  MOVWF  2B
155A:  BCF    03.6
155B:  MOVF   5C,W
155C:  BSF    03.6
155D:  MOVWF  2A
155E:  BCF    03.6
155F:  MOVF   5B,W
1560:  BSF    03.6
1561:  MOVWF  29
1562:  BCF    03.6
1563:  CALL   07C
1564:  MOVLW  20
1565:  BTFSS  0C.4
1566:  GOTO   565
1567:  MOVWF  19
1568:  MOVLW  0D
1569:  BTFSS  0C.4
156A:  GOTO   569
156B:  MOVWF  19
....................             break; 
156C:  GOTO   6F4
....................              
....................              
....................          case '6': 
....................             param=2; 
156D:  MOVLW  02
156E:  MOVWF  7C
....................             printf("\n\r\nParametros de velocidad afectados x 100 para tener mas resolucion:\n\r"); 
156F:  BSF    03.6
1570:  CLRF   28
1571:  MOVF   28,W
1572:  BCF    0A.4
1573:  BCF    03.6
1574:  CALL   1EE
1575:  BSF    0A.4
1576:  BSF    03.6
1577:  INCF   28,F
1578:  MOVWF  77
1579:  BCF    03.6
157A:  BTFSS  0C.4
157B:  GOTO   57A
157C:  MOVWF  19
157D:  MOVLW  47
157E:  BSF    03.6
157F:  SUBWF  28,W
1580:  BTFSS  03.2
1581:  GOTO   571
....................             printf("\n\r   > Introduzca B0\n\r"); 
1582:  CLRF   28
1583:  MOVF   28,W
1584:  BCF    0A.4
1585:  BCF    03.6
1586:  CALL   1AA
1587:  BSF    0A.4
1588:  BSF    03.6
1589:  INCF   28,F
158A:  MOVWF  77
158B:  BCF    03.6
158C:  BTFSS  0C.4
158D:  GOTO   58C
158E:  MOVWF  19
158F:  MOVLW  16
1590:  BSF    03.6
1591:  SUBWF  28,W
1592:  BTFSS  03.2
1593:  GOTO   583
....................             gets(texto);  
1594:  MOVLW  31
1595:  MOVWF  04
1596:  BCF    03.7
1597:  DECF   04,F
1598:  INCF   04,F
1599:  BCF    03.6
159A:  BTFSS  0C.5
159B:  GOTO   59A
159C:  MOVF   1A,W
159D:  MOVWF  00
159E:  MOVLW  0D
159F:  SUBWF  00,W
15A0:  BTFSC  03.2
15A1:  GOTO   5A4
15A2:  BSF    03.6
15A3:  GOTO   598
15A4:  CLRF   00
....................             b0=atoi32(texto); 
15A5:  BSF    03.6
15A6:  CLRF   29
15A7:  MOVLW  31
15A8:  MOVWF  28
15A9:  BCF    0A.4
15AA:  BSF    0A.3
15AB:  BCF    03.6
15AC:  CALL   420
15AD:  BSF    0A.4
15AE:  BCF    0A.3
15AF:  MOVF   7A,W
15B0:  MOVWF  5E
15B1:  MOVF   79,W
15B2:  MOVWF  5D
15B3:  MOVF   78,W
15B4:  MOVWF  5C
15B5:  MOVF   77,W
15B6:  MOVWF  5B
....................             printf("\n\r    Nuevo valor de B0 x 100 = %ld \r",b0);  
15B7:  BSF    03.6
15B8:  CLRF   28
15B9:  MOVF   28,W
15BA:  BCF    0A.4
15BB:  BCF    03.6
15BC:  CALL   23D
15BD:  BSF    0A.4
15BE:  BSF    03.6
15BF:  INCF   28,F
15C0:  MOVWF  77
15C1:  BCF    03.6
15C2:  BTFSS  0C.4
15C3:  GOTO   5C2
15C4:  MOVWF  19
15C5:  MOVLW  20
15C6:  BSF    03.6
15C7:  SUBWF  28,W
15C8:  BTFSS  03.2
15C9:  GOTO   5B9
15CA:  MOVLW  41
15CB:  MOVWF  04
15CC:  BCF    03.6
15CD:  MOVF   5E,W
15CE:  BSF    03.6
15CF:  MOVWF  2C
15D0:  BCF    03.6
15D1:  MOVF   5D,W
15D2:  BSF    03.6
15D3:  MOVWF  2B
15D4:  BCF    03.6
15D5:  MOVF   5C,W
15D6:  BSF    03.6
15D7:  MOVWF  2A
15D8:  BCF    03.6
15D9:  MOVF   5B,W
15DA:  BSF    03.6
15DB:  MOVWF  29
15DC:  BCF    03.6
15DD:  CALL   07C
15DE:  MOVLW  20
15DF:  BTFSS  0C.4
15E0:  GOTO   5DF
15E1:  MOVWF  19
15E2:  MOVLW  0D
15E3:  BTFSS  0C.4
15E4:  GOTO   5E3
15E5:  MOVWF  19
....................  
....................             printf("\n\r   > Introduzca B1\n\r"); 
15E6:  BSF    03.6
15E7:  CLRF   28
15E8:  MOVF   28,W
15E9:  BCF    0A.4
15EA:  BCF    03.6
15EB:  CALL   267
15EC:  BSF    0A.4
15ED:  BSF    03.6
15EE:  INCF   28,F
15EF:  MOVWF  77
15F0:  BCF    03.6
15F1:  BTFSS  0C.4
15F2:  GOTO   5F1
15F3:  MOVWF  19
15F4:  MOVLW  16
15F5:  BSF    03.6
15F6:  SUBWF  28,W
15F7:  BTFSS  03.2
15F8:  GOTO   5E8
....................             gets(texto);  
15F9:  MOVLW  31
15FA:  MOVWF  04
15FB:  BCF    03.7
15FC:  DECF   04,F
15FD:  INCF   04,F
15FE:  BCF    03.6
15FF:  BTFSS  0C.5
1600:  GOTO   5FF
1601:  MOVF   1A,W
1602:  MOVWF  00
1603:  MOVLW  0D
1604:  SUBWF  00,W
1605:  BTFSC  03.2
1606:  GOTO   609
1607:  BSF    03.6
1608:  GOTO   5FD
1609:  CLRF   00
....................             b1=atoi32(texto); 
160A:  BSF    03.6
160B:  CLRF   29
160C:  MOVLW  31
160D:  MOVWF  28
160E:  BCF    0A.4
160F:  BSF    0A.3
1610:  BCF    03.6
1611:  CALL   420
1612:  BSF    0A.4
1613:  BCF    0A.3
1614:  MOVF   7A,W
1615:  MOVWF  62
1616:  MOVF   79,W
1617:  MOVWF  61
1618:  MOVF   78,W
1619:  MOVWF  60
161A:  MOVF   77,W
161B:  MOVWF  5F
....................             printf("\n\r    Nuevo valor de B1 x 100 = %ld \r",b1);  
161C:  BSF    03.6
161D:  CLRF   28
161E:  MOVF   28,W
161F:  BCF    0A.4
1620:  BCF    03.6
1621:  CALL   282
1622:  BSF    0A.4
1623:  BSF    03.6
1624:  INCF   28,F
1625:  MOVWF  77
1626:  BCF    03.6
1627:  BTFSS  0C.4
1628:  GOTO   627
1629:  MOVWF  19
162A:  MOVLW  20
162B:  BSF    03.6
162C:  SUBWF  28,W
162D:  BTFSS  03.2
162E:  GOTO   61E
162F:  MOVLW  41
1630:  MOVWF  04
1631:  BCF    03.6
1632:  MOVF   62,W
1633:  BSF    03.6
1634:  MOVWF  2C
1635:  BCF    03.6
1636:  MOVF   61,W
1637:  BSF    03.6
1638:  MOVWF  2B
1639:  BCF    03.6
163A:  MOVF   60,W
163B:  BSF    03.6
163C:  MOVWF  2A
163D:  BCF    03.6
163E:  MOVF   5F,W
163F:  BSF    03.6
1640:  MOVWF  29
1641:  BCF    03.6
1642:  CALL   07C
1643:  MOVLW  20
1644:  BTFSS  0C.4
1645:  GOTO   644
1646:  MOVWF  19
1647:  MOVLW  0D
1648:  BTFSS  0C.4
1649:  GOTO   648
164A:  MOVWF  19
....................             break; 
164B:  GOTO   6F4
....................              
....................              
....................          case '7': 
....................             param=0; 
164C:  CLRF   7C
....................             printf("\n\rParametros de los controladores por defecto."); 
164D:  BSF    03.6
164E:  CLRF   28
164F:  MOVF   28,W
1650:  BCF    0A.4
1651:  BCF    03.6
1652:  CALL   2AC
1653:  BSF    0A.4
1654:  BSF    03.6
1655:  INCF   28,F
1656:  MOVWF  77
1657:  BCF    03.6
1658:  BTFSS  0C.4
1659:  GOTO   658
165A:  MOVWF  19
165B:  MOVLW  2E
165C:  BSF    03.6
165D:  SUBWF  28,W
165E:  BTFSS  03.2
165F:  GOTO   64F
....................             break; 
1660:  BCF    03.6
1661:  GOTO   6F4
....................              
....................              
....................         default:  
....................             printf("\n\Menu:");   // MENU QUE SE DESPLIEGA POR DEFAULT AL NO RECIBIR 
1662:  BSF    03.6
1663:  CLRF   28
1664:  MOVF   28,W
1665:  BCF    0A.4
1666:  BCF    03.6
1667:  CALL   2DF
1668:  BSF    0A.4
1669:  BSF    03.6
166A:  INCF   28,F
166B:  MOVWF  77
166C:  BCF    03.6
166D:  BTFSS  0C.4
166E:  GOTO   66D
166F:  MOVWF  19
1670:  MOVLW  06
1671:  BSF    03.6
1672:  SUBWF  28,W
1673:  BTFSS  03.2
1674:  GOTO   664
....................             printf("\n\r   '1' POS -> POTE");      // LAS TECLAS ANTERIORES 
1675:  CLRF   28
1676:  MOVF   28,W
1677:  BCF    0A.4
1678:  BCF    03.6
1679:  CALL   2EA
167A:  BSF    0A.4
167B:  BSF    03.6
167C:  INCF   28,F
167D:  MOVWF  77
167E:  BCF    03.6
167F:  BTFSS  0C.4
1680:  GOTO   67F
1681:  MOVWF  19
1682:  MOVLW  14
1683:  BSF    03.6
1684:  SUBWF  28,W
1685:  BTFSS  03.2
1686:  GOTO   676
....................             printf("\n\r   '2' POS -> TECLADO"); 
1687:  CLRF   28
1688:  MOVF   28,W
1689:  BCF    0A.4
168A:  BCF    03.6
168B:  CALL   306
168C:  BSF    0A.4
168D:  BSF    03.6
168E:  INCF   28,F
168F:  MOVWF  77
1690:  BCF    03.6
1691:  BTFSS  0C.4
1692:  GOTO   691
1693:  MOVWF  19
1694:  MOVLW  17
1695:  BSF    03.6
1696:  SUBWF  28,W
1697:  BTFSS  03.2
1698:  GOTO   688
....................             printf("\n\r   '3' VEL -> POTE"); 
1699:  CLRF   28
169A:  MOVF   28,W
169B:  BCF    0A.4
169C:  BCF    03.6
169D:  CALL   322
169E:  BSF    0A.4
169F:  BSF    03.6
16A0:  INCF   28,F
16A1:  MOVWF  77
16A2:  BCF    03.6
16A3:  BTFSS  0C.4
16A4:  GOTO   6A3
16A5:  MOVWF  19
16A6:  MOVLW  14
16A7:  BSF    03.6
16A8:  SUBWF  28,W
16A9:  BTFSS  03.2
16AA:  GOTO   69A
....................             printf("\n\r   '4' VEL -> TECLADO\n\r"); 
16AB:  CLRF   28
16AC:  MOVF   28,W
16AD:  BCF    0A.4
16AE:  BCF    03.6
16AF:  CALL   33B
16B0:  BSF    0A.4
16B1:  BSF    03.6
16B2:  INCF   28,F
16B3:  MOVWF  77
16B4:  BCF    03.6
16B5:  BTFSS  0C.4
16B6:  GOTO   6B5
16B7:  MOVWF  19
16B8:  MOVLW  19
16B9:  BSF    03.6
16BA:  SUBWF  28,W
16BB:  BTFSS  03.2
16BC:  GOTO   6AC
....................             printf("\n\r   '5' Edicion Controlador POS"); 
16BD:  CLRF   28
16BE:  MOVF   28,W
16BF:  BCF    0A.4
16C0:  BCF    03.6
16C1:  CALL   359
16C2:  BSF    0A.4
16C3:  BSF    03.6
16C4:  INCF   28,F
16C5:  MOVWF  77
16C6:  BCF    03.6
16C7:  BTFSS  0C.4
16C8:  GOTO   6C7
16C9:  MOVWF  19
16CA:  MOVLW  20
16CB:  BSF    03.6
16CC:  SUBWF  28,W
16CD:  BTFSS  03.2
16CE:  GOTO   6BE
....................             printf("\n\r   '6' Edicion Controlador VEL"); 
16CF:  CLRF   28
16D0:  MOVF   28,W
16D1:  BCF    0A.4
16D2:  BCF    03.6
16D3:  CALL   37E
16D4:  BSF    0A.4
16D5:  BSF    03.6
16D6:  INCF   28,F
16D7:  MOVWF  77
16D8:  BCF    03.6
16D9:  BTFSS  0C.4
16DA:  GOTO   6D9
16DB:  MOVWF  19
16DC:  MOVLW  20
16DD:  BSF    03.6
16DE:  SUBWF  28,W
16DF:  BTFSS  03.2
16E0:  GOTO   6D0
....................             printf("\n\r   '7' Controlador por defecto"); 
16E1:  CLRF   28
16E2:  MOVF   28,W
16E3:  BCF    0A.4
16E4:  BCF    03.6
16E5:  CALL   3A3
16E6:  BSF    0A.4
16E7:  BSF    03.6
16E8:  INCF   28,F
16E9:  MOVWF  77
16EA:  BCF    03.6
16EB:  BTFSS  0C.4
16EC:  GOTO   6EB
16ED:  MOVWF  19
16EE:  MOVLW  20
16EF:  BSF    03.6
16F0:  SUBWF  28,W
16F1:  BTFSS  03.2
16F2:  GOTO   6E2
16F3:  BCF    03.6
....................  
....................       } 
....................  
....................    }    
....................    output_bit(PIN_B5,0);      // destello LED LINK 
16F4:  BCF    06.5
16F5:  BSF    03.5
16F6:  BCF    06.5
....................    return; 
.................... } 
....................  
....................  
.................... // IRQ AD: Fin de conversion AD 
.................... // ======= 
16F7:  BCF    03.5
16F8:  BCF    0C.5
16F9:  BCF    0A.3
16FA:  BCF    0A.4
16FB:  GOTO   029
.................... #int_AD 
.................... void AD(void) 
.................... {   
....................    switch(modo) 
....................    {    
16FC:  MOVLW  01
16FD:  SUBWF  30,W
16FE:  ADDLW  FC
16FF:  BTFSC  03.0
1700:  GOTO   767
1701:  ADDLW  04
1702:  GOTO   76B
....................      case 1:   // presiono "4" 
....................          velocidad(); 
1703:  BCF    0A.4
1704:  BSF    0A.3
1705:  CALL   59F
1706:  BSF    0A.4
1707:  BCF    0A.3
....................             output_bit(PIN_B1,0); 
1708:  BCF    06.1
1709:  BSF    03.5
170A:  BCF    06.1
....................             output_bit(PIN_B2,0); 
170B:  BCF    03.5
170C:  BCF    06.2
170D:  BSF    03.5
170E:  BCF    06.2
....................             output_bit(PIN_B3,0); 
170F:  BCF    03.5
1710:  BCF    06.3
1711:  BSF    03.5
1712:  BCF    06.3
....................             output_bit(PIN_B4,1); 
1713:  BCF    03.5
1714:  BSF    06.4
1715:  BSF    03.5
1716:  BCF    06.4
....................             output_bit(PIN_B5,0);   
1717:  BCF    03.5
1718:  BCF    06.5
1719:  BSF    03.5
171A:  BCF    06.5
....................       break; 
171B:  BCF    03.5
171C:  GOTO   767
....................  
....................  
....................       case 2:   // presiono "2" 
....................          posicion();  
171D:  BCF    0A.4
171E:  BSF    0A.3
171F:  CALL   186
1720:  BSF    0A.4
1721:  BCF    0A.3
....................             output_bit(PIN_B1,0); 
1722:  BCF    06.1
1723:  BSF    03.5
1724:  BCF    06.1
....................             output_bit(PIN_B2,1); 
1725:  BCF    03.5
1726:  BSF    06.2
1727:  BSF    03.5
1728:  BCF    06.2
....................             output_bit(PIN_B3,0); 
1729:  BCF    03.5
172A:  BCF    06.3
172B:  BSF    03.5
172C:  BCF    06.3
....................             output_bit(PIN_B4,0); 
172D:  BCF    03.5
172E:  BCF    06.4
172F:  BSF    03.5
1730:  BCF    06.4
....................             output_bit(PIN_B5,0); 
1731:  BCF    03.5
1732:  BCF    06.5
1733:  BSF    03.5
1734:  BCF    06.5
....................       break; 
1735:  BCF    03.5
1736:  GOTO   767
....................  
....................  
....................       case 3:  // presiono "3" 
....................          RefVel(); 
1737:  CALL   000
....................             output_bit(PIN_B1,0); 
1738:  BCF    06.1
1739:  BSF    03.5
173A:  BCF    06.1
....................             output_bit(PIN_B2,0); 
173B:  BCF    03.5
173C:  BCF    06.2
173D:  BSF    03.5
173E:  BCF    06.2
....................             output_bit(PIN_B3,1); 
173F:  BCF    03.5
1740:  BSF    06.3
1741:  BSF    03.5
1742:  BCF    06.3
....................             output_bit(PIN_B4,0); 
1743:  BCF    03.5
1744:  BCF    06.4
1745:  BSF    03.5
1746:  BCF    06.4
....................             output_bit(PIN_B5,0); 
1747:  BCF    03.5
1748:  BCF    06.5
1749:  BSF    03.5
174A:  BCF    06.5
....................       break; 
174B:  BCF    03.5
174C:  GOTO   767
....................  
....................  
....................       case 4:  // presiono "1" 
....................          RefPos(); 
174D:  BCF    0A.4
174E:  BSF    0A.3
174F:  CALL   3A1
1750:  BSF    0A.4
1751:  BCF    0A.3
....................             output_bit(PIN_B1,1); 
1752:  BSF    06.1
1753:  BSF    03.5
1754:  BCF    06.1
....................             output_bit(PIN_B2,0); 
1755:  BCF    03.5
1756:  BCF    06.2
1757:  BSF    03.5
1758:  BCF    06.2
....................             output_bit(PIN_B3,0); 
1759:  BCF    03.5
175A:  BCF    06.3
175B:  BSF    03.5
175C:  BCF    06.3
....................             output_bit(PIN_B4,0); 
175D:  BCF    03.5
175E:  BCF    06.4
175F:  BSF    03.5
1760:  BCF    06.4
....................             output_bit(PIN_B5,0); 
1761:  BCF    03.5
1762:  BCF    06.5
1763:  BSF    03.5
1764:  BCF    06.5
....................       break; 
1765:  BCF    03.5
1766:  GOTO   767
....................    } 
.................... } 
....................  
....................  
.................... // main: programa principal, iniciliza el dispositivo y queda operando por IRQs 
.................... // ===== 
.................... // 
.................... // Recibe: nada 
.................... // Retorna: nada 
1767:  BCF    0C.6
1768:  BCF    0A.3
1769:  BCF    0A.4
176A:  GOTO   029
.................... void main(void) 
.................... { 
*
1965:  CLRF   04
1966:  BCF    03.7
1967:  MOVLW  1F
1968:  ANDWF  03,F
1969:  MOVLW  0C
196A:  BSF    03.5
196B:  MOVWF  19
196C:  MOVLW  A2
196D:  MOVWF  18
196E:  MOVLW  90
196F:  BCF    03.5
1970:  MOVWF  18
1971:  BSF    03.5
1972:  BSF    1F.0
1973:  BSF    1F.1
1974:  BSF    1F.2
1975:  BCF    1F.3
1976:  MOVLW  07
1977:  MOVWF  1C
....................  setup_psp(PSP_DISABLED); 
*
1985:  BCF    09.4
....................  setup_spi(SPI_SS_DISABLED); 
1986:  BCF    03.5
1987:  BCF    14.5
1988:  BSF    03.5
1989:  BCF    6A.5
198A:  MOVF   6A,W
198B:  MOVWF  07
198C:  BSF    6A.4
198D:  MOVF   6A,W
198E:  MOVWF  07
198F:  BCF    6A.3
1990:  MOVF   6A,W
1991:  MOVWF  07
1992:  MOVLW  01
1993:  BCF    03.5
1994:  MOVWF  14
1995:  MOVLW  00
1996:  BSF    03.5
1997:  MOVWF  14
....................  
....................  // Inicializa el conversor A/D 
....................  setup_adc_ports(AN0_AN1_AN2_AN3_AN4);    
1998:  BCF    1F.0
1999:  BSF    1F.1
199A:  BCF    1F.2
199B:  BCF    1F.3
....................  setup_adc(ADC_CLOCK_DIV_32);       
199C:  BCF    1F.6
199D:  BCF    03.5
199E:  BCF    1F.6
199F:  BSF    1F.7
19A0:  BSF    03.5
19A1:  BSF    1F.7
19A2:  BCF    03.5
19A3:  BSF    1F.0
....................                                      
....................  // Configuro el CCP2 para usar con el Timer1 
....................  setup_ccp2(CCP_COMPARE_RESET_TIMER);    
19A4:  BSF    03.5
19A5:  BSF    6A.1
19A6:  MOVF   6A,W
19A7:  MOVWF  07
19A8:  MOVLW  0B
19A9:  BCF    03.5
19AA:  MOVWF  1D
....................     
....................  setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32);      //Timer 0 de 4ms 
19AB:  BSF    03.5
19AC:  MOVF   01,W
19AD:  ANDLW  C0
19AE:  IORLW  04
19AF:  MOVWF  01
....................  set_timer0(6);                              //refresco displays 
19B0:  MOVLW  06
19B1:  BCF    03.5
19B2:  MOVWF  01
....................  
....................  // Config Timer1 -> Muestreo 
....................  // impongo cada T=10ms  // PS=1 ; TMR1= 0  
....................  setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);   //Timer 1 
19B3:  MOVLW  85
19B4:  MOVWF  10
....................  set_timer1(0);                            // TMR1 (16 bits) 
19B5:  CLRF   0F
19B6:  CLRF   0E
....................        
....................  CCP_2=20000;                  //muestreo cada 10mseg 
19B7:  MOVLW  4E
19B8:  MOVWF  1C
19B9:  MOVLW  20
19BA:  MOVWF  1B
....................    
....................  ///timer 2 para PWM  
....................  // prescaler=16, PR2=249, postscaler=1 (no se emplea en Timer2)  
....................  setup_timer_2(T2_DIV_BY_16,249,1);       
19BB:  MOVLW  00
19BC:  MOVWF  78
19BD:  IORLW  06
19BE:  MOVWF  12
19BF:  MOVLW  F9
19C0:  BSF    03.5
19C1:  MOVWF  12
....................  setup_ccp1(CCP_PWM);            //tPWM= 2ms 
19C2:  BCF    6A.2
19C3:  MOVF   6A,W
19C4:  MOVWF  07
19C5:  BCF    03.5
19C6:  BCF    07.2
19C7:  MOVLW  0C
19C8:  MOVWF  17
....................     
....................  setup_comparator(NC_NC_NC_NC); 
19C9:  MOVLW  07
19CA:  BSF    03.5
19CB:  MOVWF  1C
19CC:  MOVF   05,W
19CD:  MOVWF  05
19CE:  MOVLW  06
19CF:  MOVWF  77
19D0:  DECFSZ 77,F
19D1:  GOTO   1D0
19D2:  NOP
19D3:  MOVF   1C,W
19D4:  BCF    03.5
19D5:  BCF    0D.6
....................  setup_vref(FALSE); 
19D6:  BSF    03.5
19D7:  CLRF   1D
....................      
....................  enable_interrupts(INT_RDA);            // Habilitamos IRQs 
19D8:  BSF    0C.5
....................  enable_interrupts(global);  
19D9:  MOVLW  C0
19DA:  BCF    03.5
19DB:  IORWF  0B,F
....................  enable_interrupts(INT_TIMER0); 
19DC:  BSF    0B.5
....................  enable_interrupts(INT_AD);    
19DD:  BSF    03.5
19DE:  BSF    0C.6
....................  
....................  
....................  //condiguramos los puertos B D y E como salidas 
....................  TRISB= 0x01;         //LEDS 
19DF:  MOVLW  01
19E0:  MOVWF  06
....................  TRISC= 0x80; 
19E1:  MOVLW  80
19E2:  MOVWF  07
....................  TRISE= 0x00;         //seccion de uni dec cen 
19E3:  CLRF   09
....................  TRISD= 0x00;         //DISPLAY 
19E4:  CLRF   08
....................  
....................  //Se manda 0 por el PORTB al principio 
....................  PORTB=0x01; 
19E5:  MOVLW  01
19E6:  BCF    03.5
19E7:  MOVWF  06
....................  PORTD=0x00; 
19E8:  CLRF   08
....................  PORTE=0x00;  
19E9:  CLRF   09
....................  
....................  //Inicializamos nulos los vectores de texto 
....................  texto[0]=0; 
19EA:  CLRF   31
....................  text1[0]=0; 
19EB:  CLRF   3B
....................  text2[0]=0; 
19EC:  CLRF   40
....................  text3[0]=0; 
19ED:  CLRF   4A
....................  modo=0; 
19EE:  CLRF   30
....................  numero=0; 
19EF:  BSF    03.5
19F0:  CLRF   67
19F1:  CLRF   66
19F2:  CLRF   65
19F3:  CLRF   64
....................  
....................  //Inicializamos vacias las colas del controlador 
....................  ini_cola(erropos,MPOS+1); 
19F4:  CLRF   6C
19F5:  MOVLW  D8
19F6:  MOVWF  6B
19F7:  MOVLW  02
19F8:  MOVWF  6D
19F9:  BCF    0A.4
19FA:  BCF    03.5
19FB:  CALL   7CF
19FC:  BSF    0A.4
....................  ini_cola(errovel,MVEL+1); 
19FD:  BSF    03.5
19FE:  CLRF   6C
19FF:  MOVLW  AC
1A00:  MOVWF  6B
1A01:  MOVLW  02
1A02:  MOVWF  6D
1A03:  BCF    0A.4
1A04:  BCF    03.5
1A05:  CALL   7CF
1A06:  BSF    0A.4
....................  ini_cola(ukpos,MPOS+1); 
1A07:  BSF    03.5
1A08:  CLRF   6C
1A09:  MOVLW  E0
1A0A:  MOVWF  6B
1A0B:  MOVLW  02
1A0C:  MOVWF  6D
1A0D:  BCF    0A.4
1A0E:  BCF    03.5
1A0F:  CALL   7CF
1A10:  BSF    0A.4
....................  ini_cola(ukvel,MVEL+1); 
1A11:  BSF    03.5
1A12:  CLRF   6C
1A13:  MOVLW  B4
1A14:  MOVWF  6B
1A15:  MOVLW  02
1A16:  MOVWF  6D
1A17:  BCF    0A.4
1A18:  BCF    03.5
1A19:  CALL   7CF
1A1A:  BSF    0A.4
....................  
....................  // MENU INICIAL         
....................  printf("\n\Menu:            VERSION: g04");    
1A1B:  BSF    03.5
1A1C:  CLRF   6B
1A1D:  MOVF   6B,W
1A1E:  BCF    0A.4
1A1F:  BCF    0A.3
1A20:  BCF    03.5
1A21:  CALL   3C8
1A22:  BSF    0A.4
1A23:  BSF    0A.3
1A24:  BSF    03.5
1A25:  INCF   6B,F
1A26:  MOVWF  77
1A27:  BCF    03.5
1A28:  BTFSS  0C.4
1A29:  GOTO   228
1A2A:  MOVWF  19
1A2B:  MOVLW  1E
1A2C:  BSF    03.5
1A2D:  SUBWF  6B,W
1A2E:  BTFSS  03.2
1A2F:  GOTO   21D
....................  printf("\n\r   '1' POS -> POTE");      
1A30:  CLRF   6B
1A31:  MOVF   6B,W
1A32:  BCF    0A.4
1A33:  BCF    0A.3
1A34:  BCF    03.5
1A35:  CALL   2EA
1A36:  BSF    0A.4
1A37:  BSF    0A.3
1A38:  BSF    03.5
1A39:  INCF   6B,F
1A3A:  MOVWF  77
1A3B:  BCF    03.5
1A3C:  BTFSS  0C.4
1A3D:  GOTO   23C
1A3E:  MOVWF  19
1A3F:  MOVLW  14
1A40:  BSF    03.5
1A41:  SUBWF  6B,W
1A42:  BTFSS  03.2
1A43:  GOTO   231
....................  printf("\n\r   '2' POS -> TECLADO"); 
1A44:  CLRF   6B
1A45:  MOVF   6B,W
1A46:  BCF    0A.4
1A47:  BCF    0A.3
1A48:  BCF    03.5
1A49:  CALL   306
1A4A:  BSF    0A.4
1A4B:  BSF    0A.3
1A4C:  BSF    03.5
1A4D:  INCF   6B,F
1A4E:  MOVWF  77
1A4F:  BCF    03.5
1A50:  BTFSS  0C.4
1A51:  GOTO   250
1A52:  MOVWF  19
1A53:  MOVLW  17
1A54:  BSF    03.5
1A55:  SUBWF  6B,W
1A56:  BTFSS  03.2
1A57:  GOTO   245
....................  printf("\n\r   '3' VEL -> POTE"); 
1A58:  CLRF   6B
1A59:  MOVF   6B,W
1A5A:  BCF    0A.4
1A5B:  BCF    0A.3
1A5C:  BCF    03.5
1A5D:  CALL   322
1A5E:  BSF    0A.4
1A5F:  BSF    0A.3
1A60:  BSF    03.5
1A61:  INCF   6B,F
1A62:  MOVWF  77
1A63:  BCF    03.5
1A64:  BTFSS  0C.4
1A65:  GOTO   264
1A66:  MOVWF  19
1A67:  MOVLW  14
1A68:  BSF    03.5
1A69:  SUBWF  6B,W
1A6A:  BTFSS  03.2
1A6B:  GOTO   259
....................  printf("\n\r   '4' VEL -> TECLADO\n\r"); 
1A6C:  CLRF   6B
1A6D:  MOVF   6B,W
1A6E:  BCF    0A.4
1A6F:  BCF    0A.3
1A70:  BCF    03.5
1A71:  CALL   33B
1A72:  BSF    0A.4
1A73:  BSF    0A.3
1A74:  BSF    03.5
1A75:  INCF   6B,F
1A76:  MOVWF  77
1A77:  BCF    03.5
1A78:  BTFSS  0C.4
1A79:  GOTO   278
1A7A:  MOVWF  19
1A7B:  MOVLW  19
1A7C:  BSF    03.5
1A7D:  SUBWF  6B,W
1A7E:  BTFSS  03.2
1A7F:  GOTO   26D
....................  printf("\n\r   '5' Edicion Controlador POS"); 
1A80:  CLRF   6B
1A81:  MOVF   6B,W
1A82:  BCF    0A.4
1A83:  BCF    0A.3
1A84:  BCF    03.5
1A85:  CALL   359
1A86:  BSF    0A.4
1A87:  BSF    0A.3
1A88:  BSF    03.5
1A89:  INCF   6B,F
1A8A:  MOVWF  77
1A8B:  BCF    03.5
1A8C:  BTFSS  0C.4
1A8D:  GOTO   28C
1A8E:  MOVWF  19
1A8F:  MOVLW  20
1A90:  BSF    03.5
1A91:  SUBWF  6B,W
1A92:  BTFSS  03.2
1A93:  GOTO   281
....................  printf("\n\r   '6' Edicion Controlador VEL"); 
1A94:  CLRF   6B
1A95:  MOVF   6B,W
1A96:  BCF    0A.4
1A97:  BCF    0A.3
1A98:  BCF    03.5
1A99:  CALL   37E
1A9A:  BSF    0A.4
1A9B:  BSF    0A.3
1A9C:  BSF    03.5
1A9D:  INCF   6B,F
1A9E:  MOVWF  77
1A9F:  BCF    03.5
1AA0:  BTFSS  0C.4
1AA1:  GOTO   2A0
1AA2:  MOVWF  19
1AA3:  MOVLW  20
1AA4:  BSF    03.5
1AA5:  SUBWF  6B,W
1AA6:  BTFSS  03.2
1AA7:  GOTO   295
....................  printf("\n\r   '7' Controlador por defecto"); 
1AA8:  CLRF   6B
1AA9:  MOVF   6B,W
1AAA:  BCF    0A.4
1AAB:  BCF    0A.3
1AAC:  BCF    03.5
1AAD:  CALL   3A3
1AAE:  BSF    0A.4
1AAF:  BSF    0A.3
1AB0:  BSF    03.5
1AB1:  INCF   6B,F
1AB2:  MOVWF  77
1AB3:  BCF    03.5
1AB4:  BTFSS  0C.4
1AB5:  GOTO   2B4
1AB6:  MOVWF  19
1AB7:  MOVLW  20
1AB8:  BSF    03.5
1AB9:  SUBWF  6B,W
1ABA:  BTFSS  03.2
1ABB:  GOTO   2A9
....................  
....................  set_pwm1_duty(512);      // Inicializo detenido el motor 
1ABC:  MOVLW  80
1ABD:  BCF    03.5
1ABE:  MOVWF  15
1ABF:  MOVF   17,W
1AC0:  ANDLW  CF
1AC1:  MOVWF  17
....................  
....................  while(1) 
....................    {    
....................     display_FP(numero); 
1AC2:  BSF    03.5
1AC3:  MOVF   67,W
1AC4:  MOVWF  6E
1AC5:  MOVF   66,W
1AC6:  MOVWF  6D
1AC7:  MOVF   65,W
1AC8:  MOVWF  6C
1AC9:  MOVF   64,W
1ACA:  MOVWF  6B
1ACB:  BCF    03.5
1ACC:  GOTO   000
....................    } 
1ACD:  GOTO   2C2
.................... } 
1ACE:  SLEEP

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
